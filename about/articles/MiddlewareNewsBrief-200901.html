<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
<!-- tbd: modify MONTH and YEAR here here -->
<title>
                Object Computing, Inc. - Middleware News Brief -
                Issue 01, 2009</title>
<style type="text/css">
            body {
                color: rgb(0, 0, 0);
                background-color: rgb(255, 255, 255);
                font-family: Verdana, sans-serif;
                margin-left: 0.25in;
                margin-right: 0.25in;
            }
            a.career {
                font-weight: bold;
            }
            a:hover {
                color: rgb(0, 0, 255);
                background-color: rgb(255, 253, 160);
            }
            code {
                font-family: "Courier New", monospace;
            }
            div.center {
                text-align: center;
            }
            h1 {
                text-align: center;
            }
            h2 {
                text-align: left;
            }
            h3 {
                text-align: left;
            }
            h4 {
                text-align: left;
            }
            h5 {
                text-align: left;
            }
            hr {
                height: 1px;
                color: rgb(0, 0, 0);
                background-color: transparent;
            }
            hr.Color {
                height: 1px;
                color: rgb(147, 146, 143);
                background-color: transparent;
            }
            kbd {
                font-family: "Courier New", monospace;
            }
            p {
	    text-align: justify;
	    }
	    p.author {
	    text-align: center;
	    }
	    p.footer {
	    text-align: justify;
	    }
	    p.copyright {
	    text-align: justify;
	    font-size: small;
	    }
	    pre {
	    font-family: "Courier New", monospace;
	    }
	    .educationquicklinks {
	    text-align: center;
	    }
	    .quicklinks {
	    text-align: right;
	    }
	    .red {
	    color: rgb(255, 0, 0);
	    background-color: rgb(255, 255, 255);
	    }
	    .green {
	    color: rgb(0, 128, 0);
	    background-color: rgb(255, 255, 255);
	    }
	    .blue {
	    color: rgb(0, 0, 192);
	    background-color: rgb(255, 255, 255);/
	    }
	    .code {
	    background-color: #FFFFF0;
	    border: dashed black 1px;
	    padding-left: 10px;
	    }
	    .comment {
	    color: rgb(128,128,128);
	    font-weight: normal;
	    font-style: italic;
	    }
	    img {border:0;}
	    </style>
</head>
<body>
<div class="quicklinks" id="top">
<a href="http://www.ociweb.com">Home</a> |
            <a href="http://www.ociweb.com/resources/publications/mnb">Middleware News Brief Archive</a> |
            <a href="#ocieducationservices">OCI Education Services</a>
</div>
<table cellspacing="0" cellpadding="0" border="0" width="100%">
  <tr>
    <td><a href="http://www.ociweb.com"><img moz-do-not-send="true" height="120" width="180" src="http://www.ociweb.com/mnb/images/OCILogo.png" alt="" /></a></td>
    <td><img moz-do-not-send="true" height="58" width="10" src="http://www.ociweb.com/mnb/images/MiddlewareNewsBriefLeft.png" alt="" /></td>
    <td width="100%"><img moz-do-not-send="true" height="58" width="100%" src="http://www.ociweb.com/mnb/images/MiddlewareNewsBriefMiddle.png" alt="" /></td>
    <td><a href="http://www.ociweb.com/mnb"><img moz-do-not-send="true" height="58" width="382" src="http://www.ociweb.com/mnb/images/MiddlewareNewsBriefRight.png" alt="" /></a></td>
  </tr>
</table>
<div>
<hr class="Color" />
</div>

<!-- tbd: add Title and Author here -->
        <h1>Using TAO and OpenDDS with .NET, Part I</h1>
	<p class="author">
	    by<br/>
            Charles Calkins, Senior Software Engineer 
            <br/>Object Computing, Inc. (OCI)
        </p>
							    

<!-- tbd: Start the Middleware News Brief here -->

<h2>Introduction</h2>

<p>A major advantage of <a href="http://www.theaceorb.com/">TAO</a> and 
<a href="http://www.opendds.org/">OpenDDS</a>, open-source implementations of the Object
Management Group's CORBA and the Data Distribution Service, is the wide variety 
of platforms to which they have been ported.  While retaining platform neutrality
is a worthy goal, the dominance of Microsoft Windows in the PC marketplace, over  
90% <a href="#ref1">[1]</a> 
market share as of the writing of this article, encourages the use of Windows-specific features
when developing for that platform.</p>

<p>Since the release of Visual Studio.NET in 2002, Microsoft's direction for
development has been that of the 
.NET Framework <a href="#ref2">[2]</a>.  
In a manner similar to Java bytecode, high-level languages are compiled into
an assembly-like intermediate language, standardized
as the Common Language Infrastructure by Ecma International in 
ECMA-335 <a href="#ref3">[3]</a>,
which is then ultimately compiled and run on the target machine.</p>

<p>Although special languages such as C# have been created for .NET development,
C++ has the ability to use the .NET Framework as well.  How well-integrated C++
code is with the .NET Framework, though, is dependent upon how many code changes
are made to conform to the new C++/CLI syntax.  As TAO and OpenDDS are written
in standard C++, this article series will show how they can be adapted to be used in
a .NET application.</p>


<h2>Application Overview</h2>

<p>For several years, OCI has been engaged with a customer in the maintenance of a legacy
data-acquisition application.  Data is collected by remote sensing devices and 
stored in a database, and the sensing devices are managed, and the data viewed, by
an application written for Microsoft Windows.</p>

<p>Although originally a single-user application referencing a local database,
over time the application has evolved into one where multiple users can simultaneously connect to a 
single centralized database.  If one user makes a change to the database,
all other connected users must be made aware of the change so their local states can be
updated.</p>

<p>A solution to this problem is to create a single process to manage access to the
database, and to provide database change notifications to interested client applications.
Having a single process interact with the database on behalf of clients, instead of 
allowing each client direct access to the database, ensures that no database change
can be made without the system, as a whole, becoming aware of it.  Additionally, 
abstracting the details of the database access from the clients allows the database
process be moved to other hosts, or even be implemented on a different platform, without
requiring more than just a reference to the new location of the database process to 
be changed in the configuration of the clients &mdash; no client code changes would be necessary.</p>

<p>TAO and OpenDDS were selected as the middleware to accomplish this task for
two main reasons.  The first is that it is easy to be up and running quickly &mdash; 
the prototype that was developed to illustrate the architecture was completed in 
under three days.  The second is that, as both TAO and OpenDDS are open source,
there are no license fees or other costs involved.  The resulting application can
be deployed widely without incurring a per-seat, or per-CPU, or even a development/SDK
charge.</p>

<p>The existing legacy application interacts with a database
via ADO.NET <a href="#ref4">[4]</a>,
a series of classes provided by the .NET Framework, which provide a uniform
means of accessing various data source types.  The code that uses ADO.NET is
in a library, written in C#.  The main application that uses this library is
written in C++.</p>

<p>In order to solve the problem outlined above, the following architecture was designed.  In this diagram,
components written in C# shown with box hatching and components written in C++ 
shown with angled hatching.</p>
<div class="center">
<img moz-do-not-send="true" src="http://www.ociweb.com/mnb/images/200901/architecture.png" alt="" width="678" height="408" />
</div>

<p>The separate application to manage the database, called
the DataServer, was written.  This application, in C++, uses the same C#
library as before.  It now, however, acts as a CORBA server, processing
requests from clients to perform database operations.  As operations
are performed, the DataServer publishes a DDS data sample to clients to notify
them of the results of the operation.  DDS is used instead of the CORBA Notification
Service for notifications as DDS samples are strongly typed (rather than being
the CORBA Any type), plus DDS provides quality-of-service policies that
the Notification Service does not.
This
article describes the core elements of the DataServer, as well as a client
application, written in C#, that makes use of it.  The client performs
CORBA operation invocations, and subscribes to the DDS data samples.  This
article will also illustrate the use of <a href="http://www.ociweb.com/products/mpc">MPC</a>
for project maintenance.</p>

<hr/>
<p>
<strong>SIDEBAR</strong><br/>
The code in this article was developed with Microsoft Visual Studio 2005.  
It was compiled against 
<a href="http://www.theaceorb.com/downloads/1.6a/index.html">TAO version 1.6a</a>, 
<a href="http://www.opendds.org/">OpenDDS version 1.3</a>,
and <a href="http://www.ociweb.com/products/mpc">MPC version 3.7.2</a>.  
Inline assembly was disabled
to prevent the .NET-related compiler warning C4793, as the use of <code>__asm</code> forces native code
generation.  Wide character support was enabled, as .NET uses Unicode for
string representation.  The build settings for these features are as follows:</p>

<div class="code">
<pre>
// add to %ACE_ROOT%\ace\config.h
#define ACE_LACKS_INLINE_ASSEMBLY 1
#define ACE_USES_WCHAR 1

// add to %ACE_ROOT%\bin\MakeProjectCreator\config\default.features
uses_wchar=1
</pre>
</div>
<hr/>

<h2>DataLib</h2>

<p>The core functionality of the Data Server is provided by DataLib, 
a library written in C# which interacts with the database.  For this
example, we'll use <a href="http://sqlite.phxsoftware.com/">System.Data.SQLite</a>,
a public domain <a href="http://www.sqlite.org/">SQLite</a> ADO.NET provider.</p>

<p>DataLib consists of a single file, DataLib.cs, containing a single class
named <code>Database</code>, and referencing several .NET libraries as well
as System.Data.SQLite.  The structure of the <code>Database</code> class
is below.  Methods are provided to open and close the database, where, for
simplicity, a single database connection is used.  Additional methods are
provided to create, read, update and delete records in an item table, where
an item has both an autogenerated numeric ID and a description.  For
the implementation of these methods, please see the 
<a href="http://www.ociweb.com/mnb/code/mnb200901-code.zip">code archive</a> that
accompanies this article.</p>

<div class="code">
<pre>
namespace DataLib
{
    using System;
    using System.Data;
    using System.Data.SQLite;

    public class Database
    {
        // open and close the database connection
        public bool Open()
        public void Close()
        
        // create a new item, and return the autogenerated ID
        public bool CreateItem(string description, out Int64 id)
        
        // read the description from a specific item, given the item ID
        public bool ReadItem(Int64 id, out string description)
        
        // update the description of an item given its ID
        public bool UpdateItem(Int64 id, string description)
        
        // delete an item, given its ID
        public bool DeleteItem(Int64 id)
    }
}
</pre>
</div>

<h2>DataLib Project Creation</h2>

<p>Although the DataLib project can be created from within Visual Studio, using
MPC (the <em>Makefile, Project, and Workspace Creator</em>) provides a number of benefits:</p>

<ol>
<li>Different versions of Visual Studio can be supported with one set of project
description files.  Conversion of solution and project files between versions of
Visual Studio is not necessary.</li>
<li>MPC project description  (<code>.mpc</code>) files can inherit from base project 
(<code>.mpb</code>) files, allowing settings such as output directory specification or
the setting of a warning level to be made in one place and applied across all
projects.  If these settings were changed within Visual Studio, changes would
have to be made over and over again, once for each project in the solution.</li>
<li>Comments are supported in the project description files, allowing the
rationale behind the various settings to be documented.</li>
<li>Often, the default settings for projects can be used without needing to
change them, making project descriptions simple.</li>
</ol>

<p>Documentation for MPC can be found 
<a href="http://downloads.ociweb.com/MPC/docs/html/MakeProjectCreator.html">here</a>, 
though we will describe features of MPC that are useful for this application.</p>

<p>As this system will consist of several projects, we create
a base project to allow settings that all projects should inherit.  We 
also set an environment variable, <code>DATASERVER_ROOT</code>, to represent 
the top-level directory of the project.  This allows us to move the entire source tree 
while correctly maintaining any full paths used in the project files.</p>

<p>The base of all projects in the workspace is named <code>DataServerBase.mpb</code>,
and has the following contents:</p>

<div class="code">
<pre>
// DataServerBase.mpb
project {
    specific {
        Release::install = $(DATASERVER_ROOT)/Output/Release
        Debug::install = $(DATASERVER_ROOT)/Output/Debug
	
        warning_level = 4
    }  
}
</pre>
</div>

<p>When generating projects for Visual Studio, it is important to remember that
the variables set in the MPC or MPB file reflect ones set in the Visual 
Studio IDE.  Generally, settings which correspond to strings are set 
directly in the MPC or MPB file, but those that represent dropdowns
are set by the numeric index of the choice of interest in the dropdown.  In
this case, output directories are specified by name, but the warning level
is set numerically to 4, which represents the choice of <code>/W4</code> in the IDE.</p>

<p>As this project will contain different types of projects, written in
different languages, it is useful to define base projects which
apply to subsets of projects in the workspace.  The contents of the file
<code>CSBase</code> follows, the base for all C# projects.</p>

<div class="code">
<pre>
// CSBase.mpb
project : DataServerBase {
    specific {
        // to avoid "Load of property 'ReferencePath' failed.  Cannot 
        // add '.' as a reference path as it is relative. Please specify 
        // an absolute path." on C# project load into the IDE
        libpaths -= .
    }
}
</pre>
</div>

<p>By default, MPC adds the current directory to the list of directories
where libraries are found, though Visual Studio will generate a warning if the
directory is not an absolute path.  The entry above removes the current directory
from the library paths.  This project inherits from <code>DataServerBase</code>, so settings
that are made in <code>DataServerBase</code> are applied in addition to what is in this
file.</p>

<p>Finally, an MPC file is needed for the project itself.  <code>DataLib.mpc</code>
is as follows:</p>

<div class="code">
<pre>
// DataLib.mpc
project : CSBase {
    // To remove the warning "Load of property 'ReferencePath' failed.  
    // Cannot add '..\lib' as a reference path as it is relative. Please 
    // specify an absolute path."
    expand(DATASERVER_ROOT) {
        $DATASERVER_ROOT
    }  
  
    lit_libs += System System.Data System.Xml
    lit_libs += System.Data.SQLite
    libpaths += $(DATASERVER_ROOT)\lib
}
</pre>
</div>

<p>The <code>expand</code> option causes the environment variable to be treated
as an absolute path &mdash; by default, MPC converts environment variables to relative
paths.  As with the previous issue with <code>libpaths</code>, this also 
prevents a warning in Visual Studio from being generated when the
<code>lib</code> subdirectory is added.</p>

<p>As this is a .NET application, references to various .NET assemblies must be
provided, in addition to the System.Data.SQLite assembly, which provides the
database connectivity.  For this example, <code>System.Data.SQLite.dll</code> is located
in the <code>lib</code> subdirectory off of the main project directory, and the
<code>libpaths</code> entry adds that directory to the library path.</p>

<p>This project inherits from <code>CSBase</code>, so has all of the settings supplied by
<code>CSBase.mpb</code> and <code>DataServerBase.mpb</code>.</p>

<p>It is interesting to note what does not need to be specified.  As this is an
MPC file for a C# project, you do not need to provide specific names of
<code>.cs</code> files &mdash; all <code>.cs</code> files in the same directory as the MPC
file are automatically included.  Also, you do not need to specify a file
name for the output &mdash; in this instance, MPC will use the base name of the MPC
file, which is what we want.</p>


<p>With the project file created, the last step is to create a workspace (<code>.mwc</code>) file,
which corresponds to the contents of the Visual Studio solution (<code>.sln</code>)
file.  <code>DataServer.mwc</code>, located in the project root, looks like this:</p>

<div class="code">
<pre>
// DataServer.mwc
workspace {
    specific {
        cmdline += -language csharp
        DataLib
    }
}
</pre>
</div>

<p>For this project, <code>DataLib.cs</code> and <code>DataLib.mpc</code> are in a subdirectory named <code>DataLib</code>,
off of the root.  The workspace file specifies that the <code>DataLib</code> subdirectory is to be 
searched for MPC files, and that any MPC files found there should be treated as 
describing C# projects.</p>

<p>Running MPC on the MWC file generates the solution file.  The solution file
can then be opened in Visual Studio, the DataLib project compiled, and the
DataLib assembly built.  As this code was developed using Visual Studio 2005 (VC8),
we can generate the solution file by executing:</p>

<div class="code">
<pre>
%ACE_ROOT%\bin\mwc.pl -type vc8 DataServer.mwc
</pre>
</div>

<p>from a console prompt set to the project's root directory.</p>

<h2>Interface Definition Language (IDL)</h2>

<p>Now that the library for data access has been developed, we can write
a CORBA server which uses that library.  We wish to expose the functionality
of the library as a CORBA object, so an interface, described in IDL, must 
be created.  In a subdirectory named <code>IDL</code> off of the root, 
we create a file, <code>Database.idl</code>, which contains that interface.</p>

<div class="code">
<pre>
// Database.idl
interface Database
{
    boolean CreateItem(in wstring description, out long long id);
    boolean ReadItem(in long long id, out wstring description);
    boolean UpdateItem(in long long id, in wstring description);
    boolean DeleteItem(in long long id);	
};
</pre>
</div>

<p>The operations of the interface correspond to the client-accessible methods
of <code>DataLib::Database</code>, the class defined in DataLib.  The IDL types 
that are used in the 
interface correspond to the types used in C#.  In particular, strings in .NET are 
in Unicode, so <code>wstring</code> is used to pass them, and as database 
IDs are 64-bit, <code>long long</code> is needed.</p>

<p>In the IDL subdirectory, create the file <code>IDL.mpc</code> to allow the
file to be compiled by the TAO IDL compiler.</p>

<div class="code">
<pre>
// IDL.mpc
project : taoidldefaults {
    IDL_Files {
        Database.idl
    }
    custom_only = 1
}
</pre>
</div>

<p>Inheriting from the <code>taoidldefaults</code> base project, a base project included
in the TAO distribution, provides the needed infrastructure.  We only need
to list the IDL file in the <code>IDL_Files</code> section, and MPC generates
the tao_idl compilation commands.  We do need to indicate that the project
has no executable output via the <code>custom_only</code> flag, however.</p>

<p>For this project to be added to the solution file, the workspace file,
<code>DataServer.mwc</code>, must be modified to include the IDL directory.  After
the addition, <code>DataServer.mwc</code> looks like this:</p>

<div class="code">
<pre>
// DataServer.mwc
workspace {
    specific {
        cmdline += -language csharp
        DataLib
    }
    IDL
}
</pre>
</div>

<p>The IDL project is not in C#, so the IDL directory is listed outside of the
<code>specific</code> section.  The compilation of this project produces 
the client stub and server skeleton files, <code>DatabaseC.[cpp,h,inl]</code>
and <code>DatabaseS.[cpp,h,inl]</code>, respectively.</p>


<h2>Database Implementation</h2>

<p>With the database interface defined, we can create a C++ class that which
implements the interface.  We create a subdirectory off of the root named
<code>DataServer</code>, and two files in that subdirectory, <code>Database_i.h</code>
and <code>Database_i.cpp</code>.  The files as presented here were based off
of generated implementation files via the <code>-GI</code> option to <code>tao_idl</code>
and modified accordingly.  Amendments to the generated code are noted here &mdash; please
see the
<a href="http://www.ociweb.com/mnb/code/mnb200901-code.zip">code archive</a>
associated with this article for the full file listings.</p>

<p>These files define class <code>Database_i</code>, an implementation of the 
Database CORBA interface.  An instance of this implementation is called a servant.
As we would like the instance of the <code>DataLib::Database</code> class 
to be maintained by the server itself, we must be able to pass a reference to it to the
servant.  As <code>DataLib::Database</code> is a .NET class and <code>Database_i</code>
is not (as it is a standard, unmanaged C++ class), a reference to the <code>DataLib::Database</code> 
object must be stored using <code>gcroot&lt;&gt;</code>, a templated helper class
provided by the <code>vcclr.h</code> header file.  We must add <code>#include &lt;vcclr.h&gt;</code>
to the top of <code>Database_i.h</code>, and add a class member variable to class
<code>Database_i</code> to store the .NET reference (indicated by the caret) to <code>DataLib::Database</code>.</p>

<div class="code">
<pre>
// Database_i.h
class Database_i
  : public virtual POA_Database
{
    gcroot&lt;DataLib::Database^&gt; database_;
...
</pre>
</div>

<p>This variable is initialized by the <code>Database_i</code> constructor.</p>

<div class="code">
<pre>
// Database_i.h
Database_i(gcroot&lt;DataLib::Database^&gt; database);

// Database_i.cpp
Database_i::Database_i(gcroot&lt;DataLib::Database^&gt; database) : 
    database_(database)
{
}
</pre>
</div>

<p>In the methods of <code>Database_i</code>, we use the <code>database_</code> member 
variable to reference the <code>DataLib::Database</code> object, such as in the implementation of
<code>CreateItem()</code>.</p>

<div class="code">
<pre>
// Database_i.cpp
::CORBA::Boolean Database_i::CreateItem(
    const ::CORBA::WChar * description,
    ::CORBA::LongLong_out id) 
{
    System::String^ netDescription = gcnew System::String(description);
    ::CORBA::Boolean result = database_->CreateItem(netDescription, id);
    delete netDescription;
    return result;
}
</pre>
</div>

<p>Implementation of the CORBA <code>Database</code> interface is essentially
a translation between CORBA and .NET.  In this method, a string provided by 
CORBA is converted to a .NET String before being passed to 
<code>DataLib::Database::CreateItem()</code>.  The code above also illustrates
a benefit of C++/CLI.  The variable <code>netDescription</code> is 
allocated on the garbage-collected heap via <code>gcnew</code>.  It can still be determininstically
freed, however, by a call to <code>delete</code>, as if it was an allocation made
by <code>new</code> on the unmanaged heap.  However, if an exception
is thrown by the invocation of CreateItem() and <code>delete</code> is not
called, <code>netDescription</code> will still be freed by the garbage collector
when it executes at some point in the future.</p>

<p>The implementation of <code>ReadItem()</code> also involves string
translation, but this time from .NET to CORBA.</p>

<div class="code">
<pre>
// Database_i.cpp
::CORBA::Boolean Database_i::ReadItem (
    ::CORBA::LongLong id,
    ::CORBA::WString_out description)
{
    System::String^ netDescription;
    ::CORBA::Boolean result = database_->ReadItem(id, netDescription);
    if (result) {
        pin_ptr&lt;const wchar_t&gt; s = PtrToStringChars(netDescription);
        description = s;
    }
    return result;
}
</pre>
</div>

<p>The <code>pin_ptr&lt;&gt;</code> template and <code>PtrToStringChars()</code>
function are two more Visual Studio-provided helpers to assist in dealing with
.NET types in standard C++.  <code>PtrToStringChars()</code> provides a means to
directly address .NET String contents, and, as .NET strings are in Unicode, the
contents are represented as an array of <code>wchar_t</code>.  As the .NET String
is on the garbage-collected heap, <code>pin_ptr&lt;&gt;</code> is used to keep
the string contents from being relocated until access to it is complete.  It must
remain accessible until the skeleton marshals it into the GIOP reply.</p>

<p>The implementation of <code>UpdateItem()</code> and <code>DeleteItem()</code>
are analagous to the above.</p>

<h2>DataServer</h2>

<p>With the completion of the servant, we can now implement the DataServer itself.
In the file <code>DataServer.cpp</code>, the <code>main()</code> function of 
DataServer begins as most simple CORBA servers do.</p>

<div class="code">
<pre>
// DataServer.cpp
int ACE_TMAIN(int argc, ACE_TCHAR *argv[]) {
    try {
        // initialize the ORB
        CORBA::ORB_var orb = CORBA::ORB_init(argc, argv);

        // get a reference to the RootPOA
        CORBA::Object_var obj = 
            orb-&gt;resolve_initial_references("RootPOA");
        PortableServer::POA_var poa = 
            PortableServer::POA::_narrow(obj.in());

        // activate the POAManager
        PortableServer::POAManager_var mgr = poa-&gt;the_POAManager();
        mgr-&gt;activate();
</pre>
</div>

<p>To create the servant, we first create an object of type <code>DataLib::Database</code>,
open the database connection, and pass a reference to the object to 
the servant's constructor.  In this instance, the percent sign in .NET acts somewhat like an ampersand
does in standard C++ &mdash; it provides a reference to an object.</p>

<div class="code">
<pre>
        // open the database
        DataLib::Database database;
        if (!database.Open())
            throw std::exception("Cannot open the database");

        // create the Database servant
        Database_i servant(%database);
        PortableServer::ObjectId_var oid = 
            poa-&gt;activate_object(&amp;servant);
        CORBA::Object_var database_obj = poa-&gt;id_to_reference(oid.in());
</pre>
</div>

<p>There are a number of ways to provide the IOR of an object to callers, such as 
via a file or via the Naming Service.  For this application, we use the IORTable,
a TAO-specific feature which allows a client to find a server via a 
<a href="http://www.dre.vanderbilt.edu/~schmidt/DOC_ROOT/TAO/docs/INS.html">corbaloc</a> URL.</p>

<div class="code">
<pre>
        CORBA::String_var ior_str = 
            orb-&gt;object_to_string(database_obj.in());
        CORBA::Object_var tobj = 
            orb-&gt;resolve_initial_references("IORTable");
        IORTable::Table_var table = IORTable::Table::_narrow(tobj.in());
        table-&gt;bind("DataServer", ior_str.in());
        std::cout &lt;&lt; "DataServer bound to IORTable" &lt;&lt; std::endl;
</pre>
</div>

<p><code>main()</code> ends by calling <code>run()</code> on the ORB instance, 
and by providing cleanup and error reporting.</p>

<div class="code">
<pre>
        // accept requests from clients
        orb-&gt;run();
        orb-&gt;destroy();
    }
    catch (CORBA::Exception&amp; ex) {
        std::cerr &lt;&lt; "CORBA exception: " &lt;&lt; ex &lt;&lt; std::endl;
    }
    catch (std::exception&amp; ex) {
        std::cerr &lt;&lt; "Exception: " &lt;&lt; ex.what() &lt;&lt; std::endl;
    }

    return 0;
}
</pre>
</div>

<p>We next create an MPC file for the DataServer.  It is slightly more complicated
than previous MPC files.</p>

<div class="code">
<pre>
// DataServer.mpc
project : taoserver, CPPBase, iortable {
    after += IDL
    after += DataLib
  
    includes += ../IDL
    Source_Files {
        Database_i.cpp
        DataServer.cpp
        ../IDL/DatabaseC.cpp
        ../IDL/DatabaseS.cpp
    }
  
    managed = 1
}
</pre>
</div>

<p>In the same way that the IDL project inherits from the <code>taoidldefaults</code> 
base project to derive behavior,
TAO provides other base projects which allow features of TAO to be easily 
referenced by an application &mdash; these base projects set include paths, library
linkages, preprocessor symbols and other configuration options so the user
of TAO does not have to.  As DataServer is an application that uses server components
of TAO, it inherits from <code>taoserver</code>.  It uses the IORTable,
so it inherits from <code>iortable</code> as well &mdash; if it had used Naming
Service functionality, it would have inherited from <code>naming</code>.  We
desire it to have the same attributes as other C++ applications in the solution,
so it also inherits from <code>CPPBase</code>.</p>

<p>The <code>after</code> statements ensure that the IDL and DataLib projects 
are built prior to this one.  As source code files are not all located in
the same directory as the MPC file, we must specify them explicitly via the
<code>includes</code> statement and the <code>Source_Files</code> section.  
Finally, the <code>/clr</code> compiler
option must be set to allow .NET functionality to be directly used in C++ code, so 
<code>managed = 1</code> is specified.</p>

<p>This project must also be added to the workspace, leading to a <code>DataServer.mwc</code>
that looks like this:</p>

<div class="code">
<pre>
// DataServer.mwc
workspace {
    specific {
        cmdline += -language csharp
        DataLib
    }
    IDL
    DataServer
}
</pre>
</div>

<p>We then regenerate the solution file using MPC, rebuild, and now have a working
server.</p>

<hr/>
<p>
<strong>SIDEBAR</strong><br/>
As discussed in <a href="#ref5">[5]</a> and <a href="#ref6">[6]</a>,
incomplete types will generate linker warning LNK4248 when compiled with <code>/clr</code>, and is seen
with many types in TAO.  For example:</p>

<pre>
warning LNK4248: unresolved typeref token (01000016) for 
    'TAO_ORB_Core'; image may not run
</pre>

<p>The actual type that will be used is defined in 
TAO itself, which is not compiled with <code>/clr</code>.  In practice, this warning is harmless, though defining the symbol with an empty body in the module 
that generates the warning will suppress the message.  Please see the file <code>LNK4248.h</code> in the
<a href="http://www.ociweb.com/mnb/code/mnb200901-code.zip">code archive</a>
 for an approach to this issue.</p>
<hr/>

<h2>DataServerConnectorLib</h2>

<p>With the server side complete, we can begin development of the client.</p>

<p>The <code>DataServerConnectorLib</code> library acts as a client of the DataServer.  
More specifically, the class 
<code>DataServerConnector</code> in this library makes the client-side CORBA
calls to invoke methods on the server.  Although this class is implemented in C++ 
to make use of TAO, this class is a fully-fledged .NET type, so it can be used
by the Client application which is written in C#.  For future convenience, the method
<code>Run()</code> of this class is executed in a .NET thread to allow an ORB
to continue execution independent of the code that uses <code>DataServerConnector</code>,
and the <code>Start()</code> and <code>Shutdown()</code> methods manage this thread.
The other public methods of this class mirror the CORBA <code>Database</code> interface,
in appropriate .NET syntax.</p>

<p>We start by creating the file <code>DataServerConnectorLib.h</code> in the
<code>DataServerConnectorLib</code> subdirectory off of the root, and add the
following class definitions:</p>

<div class="code">
<pre>
using namespace System;
using namespace System::Threading;

class DataServerConnectorState {
    CORBA::ORB_var orb_;
    Database_var database_;
public:
    DataServerConnectorState(CORBA::ORB_ptr orb, Database_ptr database);
    Database_ptr DatabasePtr() { return database_; }
    CORBA::ORB_ptr OrbPtr() { return orb_; }
};

public ref class DataServerConnector {
    DataServerConnectorState *state_;
    Thread^ thread_;
    AutoResetEvent startupEvent_;
    void Run();
    static void ThreadStart(Object^ param);
public:
    DataServerConnector();
    ~DataServerConnector();
    void Start();
    void Shutdown();
    bool CreateItem(String ^description, Int64 %id);
    bool ReadItem(Int64 id, String^% description);
    bool UpdateItem(Int64 id, String^ description);
    bool DeleteItem(Int64 id);
};
</pre>
</div>

<p>The <code>using</code> statements allow us to use types from various .NET assemblies
without needing to specify the fully qualified names, such as <code>Thread</code>
instead of <code>System::Threading::Thread</code>.  The DataServerConnector class is declared as
a <code>public ref class</code>.  The <code>public</code> keyword indicates that the class is 
visible outside of the assembly; <code>__declspec(dllexport)</code> is not used with .NET types,
as it would be with standard Windows dynamic link libraries to export symbols.  The <code>ref</code> keyword
indicates that the class is a garbage-collected .NET type, and not an unmanaged, 
standard C++ class.</p>

<p><code>DataServerConnectorState</code> is, however, an unmanaged, standard
C++ class.  Unmanaged types (such as <code>CORBA::ORB_var</code>) cannot be
member variables of a .NET class, but pointers to unmanaged types can be.  
<code>DataServerConnectorState</code> acts as a container for the unmanaged
state of <code>DataServerConnector</code>.</p>

<p>The implementation of <code>DataServerConnectorState</code> is straightforward &mdash; it
stores ORB and servant pointers for later use.  It resides, with the implementation
of <code>DataServerConnector</code>, in the file <code>DataServerConnectorLib.cpp</code>.</p>

<div class="code">
<pre>
// DataServerConnectorLib.cpp
DataServerConnectorState::DataServerConnectorState(CORBA::ORB_ptr orb, 
    Database_ptr database) {
    orb_ = CORBA::ORB::_duplicate(orb);
    database_ = Database::_duplicate(database);
}
</pre> 
</div>

<p>The <code>Run()</code> method contains the CORBA client implementation.  Because 
<code>ORB_init()</code> requires C-style <code>argc</code> and <code>argv</code>,
they must be constructed from the .NET command-line argument array, so we begin
by performing that conversion, and then initialize the ORB.</p>

<div class="code">
<pre>
// DataServerConnectorLib.cpp
void DataServerConnector::Run() {
    int argc = 0;
    wchar_t **argv = NULL;

    try {
        // convert .NET arguments to standard argc/argv
        array&lt;String^&gt;^ arguments = Environment::GetCommandLineArgs();
        argc = arguments-&gt;Length;
        argv = new wchar_t *[argc];
        for (int i=0; i&lt;argc; i++) {
            pin_ptr&lt;const wchar_t&gt; arg = PtrToStringChars(arguments[i]);
            argv[i] = _wcsdup(arg);
        }
        
        CORBA::ORB_var orb = CORBA::ORB_init(argc, argv);        
</pre>
</div>

<p>We now obtain an object reference to the Database object.  Because the server
registered the object in the IORTable, the client can locate it by 
passing</p>

<pre>
-ORBInitRef DataServer=
    corbaloc:iiop:<em>server_hostname</em>:<em>server_port</em>/DataServer
</pre>

<p>on its command line, and calling <code>resolve_initial_references()</code>.</p>

<div class="code">
<pre>
        // obtain the reference
        CORBA::Object_var database_obj = 
            orb->resolve_initial_references("DataServer");
        if (CORBA::is_nil(database_obj.in())) 
            throw std::exception("Could not get the Database IOR");

        // narrow the IOR to a Database object reference.
        Database_var database = Database::_narrow(database_obj.in());
        if (CORBA::is_nil(database.in()))
            throw 
              std::exception("IOR was not a Database object reference");
</pre>
</div>

<p>We now store references to the ORB and Database object for later use,
run the ORB to process any requests, and perform cleanup on error.  
<code>DataConnectorException</code>, a subclass of the .NET <code>Exception</code>
class, is defined to wrap and re-throw any exceptions that are generated.  This
allows native exceptions, such as <code>CORBA::Exception</code> to be propagated
to the .NET world.</p>

<div class="code">
<pre>
        // save the references via a pointer to an unmanaged class
        state_ = new DataServerConnectorState(orb, database);

        // good to go - tell the outside world
        startupEvent_.Set();

        // run the ORB
        orb-&gt;run();
        orb-&gt;destroy();
    }
    catch (CORBA::Exception&amp; ex) {
        std::stringstream ss;
        ss &lt;&lt; "Exception: " &lt;&lt; ex;
        throw 
          gcnew DataConnectorException(gcnew String(ss.str().c_str()));
    }
    catch (std::exception&amp; ex) {
        std::stringstream ss;
        ss &lt;&lt; "Exception: " &lt;&lt; ex.what();
        throw 
          gcnew DataConnectorException(gcnew String(ss.str().c_str()));
     }
}
</pre>
</div>

<p>We must also implement methods that wrap the CORBA method invocations.
As translation was performed in the DataServer, we do the same, but in
reverse &mdash; from .NET to CORBA.  For example, <code>CreateItem()</code> is
defined below.  The .NET string is converted to a <code>CORBA::WString</code>
via the <code>PtrToStringChars()/pin_ptr&lt;&gt;</code> combination we have
used before.  The <code>CORBA::LongLong</code> used to store the <code>out</code>
parameter from the <code>CreateItem()</code> CORBA interface method is converted
to a .NET <code>Int64</code> to be returned to the caller.  Note that the percent
sign in the argument list, in this usage, acts as an <code>out</code> parameter.
As with <code>Run()</code>, exceptions are propagated as the <code>DataConnectorException</code>
type.  The other wrapper methods are analagous.</p>

<div class="code">
<pre>
// DataServerConnectorLib.cpp
bool DataServerConnector::CreateItem(String ^description, Int64 %id) {
    try {
        pin_ptr&lt;const wchar_t&gt; cppDescription = 
            PtrToStringChars(description);
        CORBA::WString_var desc = CORBA::wstring_dup(cppDescription);
        CORBA::LongLong cid;
        CORBA::Boolean result = 
            state_-&gt;DatabasePtr()-&gt;CreateItem(desc, cid);
        id = cid;
        return result;
    } catch (CORBA::Exception&amp; ex) {
        std::stringstream ss;
        ss &lt;&lt; "Exception: " &lt;&lt; ex;
        throw 
          gcnew DataConnectorException(gcnew String(ss.str().c_str()));
    }
}
</pre>
</div>

<p>After the .NET thread management methods are added, development of the
DataServerConnectorLib is complete.  We now create an MPC file for it.
The options specified are similar to those used in <code>DataServer.mpc</code>.
</p>

<div class="code">
<pre>
// DataServerConnectorLib.mpc
project : taoexe, CPPBase {
    after += IDL
    includes += ../IDL
	
    Source_Files {
        DataServerConnectorLib.cpp
        ../IDL/DatabaseC.cpp
    }
  
    managed = 1
}
</pre>
</div>

<p>We also add it to <code>DataServer.mwc</code>.</p>

<div class="code">
<pre>
// DataServer.mwc
workspace {
    specific {
        cmdline += -language csharp
        DataLib
    }
    IDL
    DataServer
    DataServerConnectorLib
}
</pre>
</div>

<p>Regenerating the solution with MPC and recompiling yields a working 
<code>DataServerConnectorLib</code>.</p>

<h2>Client</h2>

<p>The last module we will create is a GUI in C# to demonstrate the system.
The GUI consists of a ListView to display messages, and a series of Buttons
and TextBoxes to exercise the database methods.  Please refer to the
<a href="http://www.ociweb.com/mnb/code/mnb200901-code.zip">code archive</a>
 for details of the GUI itself.</p>

<p>The implementation of the button click methods invoke the corresponding
database functions &mdash; the methods exposed by the <code>DataServerConnector</code>
class.  User input into the TextBoxes associated with each button is used,
as appropriate.  For instance, the click handler for the Create button is
as follows:</p>

<div class="code">
<pre>
private void bCreate_Click(object sender, EventArgs e)
{
    try
    {
        // if input is blank, do nothing, else create the item
        if (String.IsNullOrEmpty(tCreateDesc.Text))
            return;

        // invoke the method
        long id = 0;
        if (dataConnector_.CreateItem(tCreateDesc.Text, ref id))
            Log("Item '" + tCreateDesc.Text + "' created with id " + id);
        else
            Log("Item '" + tCreateDesc.Text + "' could not be created");
    }
    catch (DataConnectorException ex)
    {
        Log(ex.Message);
    }

    // after completion (or failure) clear the input
    tCreateDesc.Text = "";
}
</pre>
</div>

<p>In this method, <code>tCreateDesc</code> is the TextBox associated
with the Create button.  If the user has entered text, it will be used
as the item description of the item to be created.  The call to <code>DataServerConnector::CreateItem()</code>
invokes the CORBA method, the ID of the created item is returned (the <code>ref</code>
in C# corresponds to the % in C++ in the argument list of <code>DataServerConnector::CreateItem()</code>), and displayed to
the user in the ListView via the call to <code>Log()</code>.  The other methods are
implemented similarly.</p>

<p>With the code complete, we create an MPC file for the Client project, as follows:</p>

<div class="code">
<pre>
// Client.mpc
project : CSBase {
    exename = Client
	
    after += DataServerConnectorLib
	
    specific {
        winapp = true
    }
	
    Source_Files {
        *.cs
        *.Designer.cs
    } 
  	
    Source_Files {
        subtype = Form
        Client.cs
    }
  	
    Resx_Files {
        generates_source = 1
        subtype = Designer
        Properties/Resources.resx
    }
  	
    lit_libs += System System.Data System.Xml 
    lit_libs += System.Drawing System.Windows.Forms
}
</pre>
</div>

<p>This MPC file is more complex than we have seen so far, due to the nature
of a graphical .NET application.  In this project, the file <code>Program.cs</code>
contains the C# <code>Main()</code> function, so unless otherwise specified, the 
output will be named <code>Program.exe</code>.  We use the
<code>exename</code> keyword to change the name of the output to <code>Client.exe</code>.
We must specify <code>winapp = true</code> as, by default, MPC will create
a console-based C# application, and Client is a GUI-based one.  Two <code>Source_Files</code>
sections are necessary, as the file <code>Client.cs</code> contains a subclass
of <code>System.Windows.Forms.Form</code> to act as the main window of the application.
<code>Form</code> code requires additional infrastructure (e.g., support for one or
more associated resource files) that normal code files do not.  The 
resource file <code>Resources.resx</code> is similar in that it has an associated 
autogenerated C# file that provides access to the resources it contains.</p>

<p>With the MPC file complete, we now add it to the workspace, yielding:</p>

<div class="code">
<pre>
// DataServer.mwc
workspace {
    specific {
        cmdline += -language csharp
        DataLib
        Client
    }
    IDL
    DataServer
    DataServerConnectorLib
}
</pre>
</div>

<h2>Conclusion</h2>

<p>The following screen shots demonstrate the system.  We start two Clients,
as well as the DataServer (not shown).  For this run, the server was run on
the machine <code>oci1373</code> and started with the following command (on a 
single line):</p>
<pre>
DataServer -ORBDottedDecimalAddresses 0 
    -ORBListenEndpoints iiop://:12346
</pre>

<p>Each of the Client instances were started with this command (on a single line):</p>
<pre>
Client -ORBDottedDecimalAddresses 0 
    -ORBInitRef DataServer=corbaloc:iiop:oci1373:12346/DataServer
</pre>

<p>We enter "My First Item" into the
TextBox associated with the Create button on the first Client.</p>

<div class="center">
<img moz-do-not-send="true" src="http://www.ociweb.com/mnb/images/200901/s1.png" alt="" width="623" height="330" />
</div>

<p>Pressing the Create button creates the database item, and the generated ID of 
1 is reflected in the ListView.</p>

<div class="center">
<img moz-do-not-send="true" src="http://www.ociweb.com/mnb/images/200901/s2.png" alt="" width="623" height="330" />
</div>

<p>On the second Client, we enter the ID of 1 into the TextBox associated with
the Read button.</p>

<div class="center">
<img moz-do-not-send="true" src="http://www.ociweb.com/mnb/images/200901/s3.png" alt="" width="622" height="329" />
</div>

<p>Pressing the Read button displays "My First Item" as the item description,
demonstrating that the second Client has referenced the same database as the
first Client.</p>

<div class="center">
<img moz-do-not-send="true" src="http://www.ociweb.com/mnb/images/200901/s4.png" alt="" width="623" height="329" />
</div>

<p>This article has described how to use TAO in a .NET application to implement
both a CORBA client and server.  The next article in this series will 
show how to incorporate OpenDDS to provide database notifications.</p>

<h2>References</h2>

<p><a name="ref1">[1]</a> Top Operating System Share Trend<br/>
<a href="http://marketshare.hitslink.com/os-market-share.aspx?qprid=9">http://marketshare.hitslink.com/os-market-share.aspx?qprid=9</a></p>

<p><a name="ref2">[2]</a> .NET Framework Overview<br/>
<a href="http://www.microsoft.com/net/overview.aspx">http://www.microsoft.com/net/overview.aspx</a></p>

<p><a name="ref3">[3]</a> Standard ECMA-335 Common Language Infrastructure (CLI)<br/>
<a href="http://www.ecma-international.org/publications/standards/Ecma-335.htm">http://www.ecma-international.org/publications/standards/Ecma-335.htm</a></p>

<p><a name="ref4">[4]</a> ADO.NET<br/>
<a href="http://msdn.microsoft.com/en-us/library/aa286484.aspx">http://msdn.microsoft.com/en-us/library/aa286484.aspx</a></p>

<p><a name="ref5">[5]</a> warning LNK4248: unresolved typeref token (01000017) for '_TREEITEM'; image may not run<br/>
<a href="http://social.msdn.microsoft.com/Forums/en-US/vclanguage/thread/0730e965-7299-44ca-8a95-59e2eb23d153">http://social.msdn.microsoft.com/Forums/en-US/vclanguage/thread/0730e965-7299-44ca-8a95-59e2eb23d153</a></p>

<p><a name="ref6">[6]</a> Linker Tools Warning LNK4248<br/>
<a href="http://msdn.microsoft.com/en-us/library/h8027ys9%28VS.80%29.aspx">http://msdn.microsoft.com/en-us/library/h8027ys9%28VS.80%29.aspx</a></p>


<!-- tbd: Stop the Middlware News Brief here -->

<hr class="Color" />
<!--#include virtual="./includes/services.html"-->
<hr class="Color" />
<!--#include virtual="./includes/footer.html"-->
<hr class="Color" />
<!--#include virtual="./includes/copyright2009.html"-->
<div class="quicklinks">
<a href="#top">Top</a>
</div>
</body>
</html>
