<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
<!-- tbd: modify MONTH and YEAR here here -->
<title>
                Object Computing, Inc. - Middleware News Brief -
                Issue 02, 2009</title>
<style type="text/css">
            body {
                color: rgb(0, 0, 0);
                background-color: rgb(255, 255, 255);
                font-family: Verdana, sans-serif;
                margin-left: 0.25in;
                margin-right: 0.25in;
            }
            a.career {
                font-weight: bold;
            }
            a:hover {
                color: rgb(0, 0, 255);
                background-color: rgb(255, 253, 160);
            }
            code {
                font-family: "Courier New", monospace;
            }
            div.center {
                text-align: center;
            }
            h1 {
                text-align: center;
            }
            h2 {
                text-align: left;
            }
            h3 {
                text-align: left;
            }
            h4 {
                text-align: left;
            }
            h5 {
                text-align: left;
            }
            hr {
                height: 1px;
                color: rgb(0, 0, 0);
                background-color: transparent;
            }
            hr.Color {
                height: 1px;
                color: rgb(147, 146, 143);
                background-color: transparent;
            }
            kbd {
                font-family: "Courier New", monospace;
            }
            p {
	    text-align: justify;
	    }
	    p.author {
	    text-align: center;
	    }
	    p.footer {
	    text-align: justify;
	    }
	    p.copyright {
	    text-align: justify;
	    font-size: small;
	    }
	    pre {
	    font-family: "Courier New", monospace;
	    }
	    .educationquicklinks {
	    text-align: center;
	    }
	    .quicklinks {
	    text-align: right;
	    }
	    .red {
	    color: rgb(255, 0, 0);
	    background-color: rgb(255, 255, 255);
	    }
	    .green {
	    color: rgb(0, 128, 0);
	    background-color: rgb(255, 255, 255);
	    }
	    .blue {
	    color: rgb(0, 0, 192);
	    background-color: rgb(255, 255, 255);
	    }
	    .code {
	    background-color: #FFFFF0;
	    border: dashed black 1px;
	    padding-left: 10px;
	    }
	    .comment {
	    color: rgb(128,128,128);
	    font-weight: normal;
	    font-style: italic;
	    }
	    img {border:0;}
	    </style>
</head>
<body>
<div class="quicklinks" id="top">
<a href="http://www.ociweb.com">Home</a> |
            <a href="http://www.ociweb.com/resources/publications/mnb">Middleware News Brief Archive</a> |
            <a href="#ocieducationservices">OCI Education Services</a>
</div>
<table cellspacing="0" cellpadding="0" border="0" width="100%">
  <tr>
      <td><a href="http://www.ociweb.com"><img moz-do-not-send="true" height="120" width="180" src="http://www.ociweb.com/mnb/images/OCILogo.png" alt="" /></a></td>
      <td><img moz-do-not-send="true" height="58" width="10" src="http://www.ociweb.com/mnb/images/MiddlewareNewsBriefLeft.png" alt="" /></td>
      <td width="100%"><img moz-do-not-send="true" height="58" width="100%" src="http://www.ociweb.com/mnb/images/MiddlewareNewsBriefMiddle.png" alt="" /></td>
      <td><a href="http://www.ociweb.com/mnb"><img moz-do-not-send="true" height="58" width="382" src="http://www.ociweb.com/mnb/images/MiddlewareNewsBriefRight.png" alt="" /></a></td>
  </tr>
</table>
<div>
<hr class="Color" />
</div>

<!-- tbd: add Title and Author here -->
        <h1>Using TAO and OpenDDS with .NET, Part&nbsp;II</h1>
	<p class="author">
	    by<br/>
            Charles Calkins, Senior Software Engineer 
            <br/>Object Computing, Inc. (OCI)
        </p>
							    

<!-- tbd: Start the Middleware News Brief here -->

<h2>Introduction</h2>

<p>For several years, OCI has been engaged with a customer in the maintenance of a legacy
data-acquisition application.  Data is collected by remote sensing devices and 
stored in a database, and the sensing devices are managed, and the data viewed, by
an application written for Microsoft Windows.</p>

<p>Although originally a single-user application referencing a local database,
over time the application has evolved into one where multiple users can simultaneously connect to a 
single centralized database.  If one user makes a change to the database,
all other connected users must be made aware of the change so their local states can be
updated.</p>

<p>A solution to this problem is to create a single process to manage access to the
database, and to provide database change notifications to interested client applications.
In <a href="MiddlewareNewsBrief-200901.html">part I</a> of this article, we described
the architecture of DataServer, an application written in a combination of C++ and C#,
that manages access to a database, and interacts with client applications
via the use of CORBA for control, such as adding, updating, and deleting
database records, and DDS for client notification.  The 
<a href="http://www.ociweb.com/">Object Computing, Inc.</a> 
distributions of <a href="http://www.theaceorb.com/">TAO</a> and 
<a href="http://www.opendds.org/">OpenDDS</a> were used as the CORBA and
DDS implementations, respectively.</p>

<p>As described in <a href="MiddlewareNewsBrief-200901.html">part I</a>, 
TAO and OpenDDS were selected as the middleware to accomplish this task for
two main reasons.  The first is that it is easy to be up and running quickly &mdash; 
the prototype that was developed to illustrate the architecture was completed in 
under three days.  The second is that, as both TAO and OpenDDS are open source,
there are no license fees or other costs involved.  The resulting application can
be deployed widely without incurring a per-seat, or per-CPU, or even a development/SDK
charge.</p>

<p>To review, the architecture is as follows, with components written 
in C# shown with box hatching and components written in C++ 
shown with angled hatching.</p>

<div class="center">
<img moz-do-not-send="true"  src="http://www.ociweb.com/mnb/images/200902/architecture.png" alt="" width="678" height="408" />
</div>

<p>In this article, we will continue the development of DataServer by
implementing the database notifications with OpenDDS.  While this article
will describe features of OpenDDS that are useful for our purpose, please
see <a href="http://www.opendds.org/Article-Intro.html">this article</a>
for more detailed information on OpenDDS itself.</p>

<p>As our objective is to notify all clients whenever any client performs
a database operation, DataServer must be able to generate notifications
as needed, and clients need to be able to receive them.  The distributed
publish and subscribe architecture of DDS is exactly what we need.</p>


<hr/>
<p>
<strong>SIDEBAR</strong><br/>
The code in this article was developed with Microsoft Visual Studio 2005.  
It was compiled against 
<a href="http://www.theaceorb.com/downloads/1.6a/index.html">TAO version 1.6a</a>, 
<a href="http://www.opendds.org/">OpenDDS version 1.3</a>,
and <a href="http://www.ociweb.com/products/mpc">MPC version 3.7.2</a>.
  Inline assembly was disabled
to prevent the .NET-related compiler warning C4793, as the use of <code>__asm</code> forces native code
generation.  Wide character support was enabled, as .NET uses Unicode for
string representation.  The build settings for these features are as follows:</p>

<div class="code">
<pre>
// add to %ACE_ROOT%\ace\config.h
#define ACE_LACKS_INLINE_ASSEMBLY 1
#define ACE_USES_WCHAR 1

// add to %ACE_ROOT%\bin\MakeProjectCreator\config\default.features
uses_wchar=1
</pre>
</div>
<hr/>

<h2>DDS/OpenDDS Overview</h2>

<p>We shall begin by reviewing the elements of DDS, and, where applicable, areas where
OpenDDS provides more specialized functionality.  OpenDDS supports the Data-Centric
Publish and Subscribe (DCPS) layer of the 
<a href="http://www.omg.org/spec/DDS/1.2/">DDS specification</a>, so it is that
layer of DDS that we will be concerned with in this article.</p>

<p>Processes that wish to exchange messages via DDS are part of one or more <em>domains</em>,
and are known as <em>domain participants</em>.
A domain is a global data space, identified by an integer.  While a given process can
join multiple domains, messages sent in one domain can only be received by other 
participants in that same domain.</p>

<p>A <em>publisher</em> is responsible for distributing data in a domain.  It may publish
data of different types, with each type published by a <em>data writer</em> associated
with that type.  Data is received by a <em>subscriber</em>, with each data type received
by a type-specific <em>data reader</em>.  <em>Quality of service (QoS)</em> policies
exist at various levels to manage the data transfer process.  Entities in a domain
such as these may also have associated <em>listeners</em> where events can be
received asynchronously when states are changed, data is received, or the like.</p>

<p>The data that is transferred between publishers and subscribers is represented
by a <em>topic</em>.  A topic has a name which is unique in the domain, a data type that is
expressed in IDL, and quality of service policies associated with the data.  A <em>sample</em>
is a particular data element of a topic, and a sample may have one or more fields 
defined as a <em>key</em>.  An <em>instance</em> is a set of samples which have the same
key.</p>

<p>OpenDDS allows samples to be transmitted using various protocols, including:
TCP (<code>SimpleTcp</code>), 
UDP (<code>SimpleUdp</code>), unreliable multicast (<code>SimpleMcast</code>),
and reliable multicast (<code>ReliableMulticast</code>).  This
is known as a <em>transport</em>.</p>

<p>In this article, we will develop a database notification topic, add
the ability for DataServer to publish samples of that topic, and for the
client application to subscribe to samples of that topic.  We will build upon 
the code developed for <a href="MiddlewareNewsBrief-200901.html">part I</a>, focusing on OpenDDS integration,
so please review the earlier article for the details of using TAO in DataServer.  Also,
while relevant code segments will be highlighted, please see the 
<a href="http://www.ociweb.com/mnb/code/mnb200902-code.zip">code archive</a> that
accompanies this article for the full details.</p>


<h2>DatabaseNotification</h2>

<p>We wish to notify all clients
of all operations that are performed on the database by other clients &mdash; reads,
writes, updates and deletes of records.  Although, for purposes of demonstration,
DataServer manages only one table named <code>Items</code>, we will include the table name
in the notification for completeness, in addition to the ID of the row that
was acted upon.</p> 

<p>For use by DDS, the database notification must be expressed in IDL.  We create
a directory, <code>DatabaseNotification</code> off of the root, and add a file, 
<code>DatabaseNotification.idl</code>, with the following contents:</p>

<div class="code">
<pre>
// DatabaseNotification.idl
enum NotificationType 
{
    NOTIFICATION_CREATED,
    NOTIFICATION_READ,
    NOTIFICATION_UPDATED,
    NOTIFICATION_DELETED
};

#pragma DCPS_DATA_TYPE "DatabaseNotification"
#pragma DCPS_DATA_KEY "DatabaseNotification id"
#pragma DCPS_DATA_KEY "DatabaseNotification table_name"
struct DatabaseNotification
{
    long long id;
    string table_name;
    NotificationType notification_type;
};
</pre>
</div>

<p>The <code>DatabaseNotification</code> structure represents the notification
itself, containing both a 64-bit table row ID, the table name with which the ID is associated,
and referencing an enumeration which specifies the various types of actions 
that can occur.  Additional information could also be provided, such as a unique
identifier representing the client that performed the action, but, for now, the above
will suffice.</p>

<p>In order for a structure expressed in IDL to be used as an OpenDDS type, the structure must
be identified by the <code>DCPS_DATA_TYPE</code> pragma.  A key
can be defined by the <code>DCPS_DATA_KEY</code> pragma, where both the containing
structure, and the field name, are provided. Here,
the key is composed of two fields: <code>id</code> and <code>table_name</code>.
A key is not required, but in this example, we use keys to identify each
unique combination of <code>table_name</code> and <code>id</code> as a separate instance.
</p>

<p>To compile the IDL definition, we next create an MPC file in the same directory
named <code>DatabaseNotification.mpc</code></p>

<div class="code">
<pre>
// DatabaseNotification.mpc
project : dcps, CPPBase {
    sharedname = DatabaseNotificationCommon
    dynamicflags = DATABASENOTIFICATIONCOMMON_BUILD_DLL 
    requires += tao_orbscvs
    includes += $(TAO_ROOT)/orbsvcs
    idlflags += -I$(TAO_ROOT)/orbsvcs
    idlflags += -Wb,export_macro=DatabaseNotificationCommon_Export
    idlflags += \
        -Wb,export_include=DatabaseNotificationCommon_Export.h
    dcps_ts_flags += --export=DatabaseNotificationCommon_Export

    TypeSupport_Files {
        DatabaseNotification.idl &gt;&gt; \
            DatabaseNotificationTypeSupport.idl \
            DatabaseNotificationTypeSupportImpl.h \
            DatabaseNotificationTypeSupportImpl.cpp
    }

    IDL_Files {
        DatabaseNotificationTypeSupport.idl
        DatabaseNotification.idl
    }

    Header_Files {
        DatabaseNotificationTypeSupportImpl.h
    }

    Source_Files {
        DatabaseNotificationTypeSupportImpl.cpp
    }
}
</pre>
</div>

<p>This project inherits from the <code>dcps</code> base project, which 
provides many definitions needed for compiling with OpenDDS.  
The result of compiling the IDL is a C++ library, <code>DatabaseNotificationCommon</code>.
The project also inherits from <code>CPPBase</code>,
as defined in <a href="MiddlewareNewsBrief-200901.html">part I</a>, to set output directories,
include paths, and other properties.</p>

<p>OpenDDS uses elements of TAO, so a dependence on <code>tao_orbscvs</code>
is needed.  Macros must be defined to manage the declaration and exporting 
of generated symbols, with the primary macro set to the name of the project, 
<code>DatabaseNotificationCommon</code>, suffixed with <code>_Export</code>.  The
definition of this and other macros is in a header file with the same name and
<code>.h</code> extension.  This command is used to create that file (typed on one
line):</p>

<pre>
generate_export_file.pl DatabaseNotificationCommon &gt; 
    DatabaseNotificationCommon_Export.h
</pre>

<p>The remaining sections of the MPC file describe the files that will be compiled
into the library.  Note that the <code>&gt;&gt;</code> indicates that the result 
of processing one file (here, running the tao_idl compiler on 
<code>DatabaseNotification.idl</code>) results in additional files being generated
which themselves must be processed to produce the library.</p>

<p>Now that the MPC file is complete, it must be added to the workspace so it can be
compiled as part of the project.  After adding <code>DatabaseNotification</code> to
the <code>DataServer.mwc</code> file, the result is as follows:</p>

<div class="code">
<pre>
// DataServer.mwc
workspace {
    specific {
        cmdline += -language csharp
        DataLib
        Client
    }
    DataServer
    DataServerConnectorLib
    IDL
    DatabaseNotification
}
</pre>
</div>

<h2>Publisher</h2>

<p>With the definition of the database notification complete, we can add the ability
to DataServer to publish notifications when database operations are performed.
We will update DataServer to be a DDS publisher by adding code to create the
relevant DDS entities, and to publish samples when database
operations are successfully executed by extending the servant that had been
created in <a href="MiddlewareNewsBrief-200901.html">part I</a>. </p>

<p>We start with defining a few constants, for convenience, to represent the domain,
as well as the notification type and topic names.  In <code>DataServer.cpp</code>,
we add the following before <code>ACE_TMAIN()</code>:</p>

<div class="code">
<pre>
DDS::DomainId_t DATABASENOTIFICATION_DOMAIN_ID = 1066;
const char* DATABASENOTIFICATION_TYPE = 
    "DatabaseNotification Type";
const char* DATABASENOTIFICATION_TOPIC = 
    "DatabaseNotification Topic";
</pre>
</div>

<p>At the start of <code>ACE_TMAIN()</code>, we define two variables that represent
fundamental DDS elements:</p>

<div class="code">
<pre>
int ACE_TMAIN(int argc, ACE_TCHAR *argv[]) {
    DDS::DomainParticipantFactory_var dpf = 
        DDS::DomainParticipantFactory::_nil();
    DDS::DomainParticipant_var participant = 
        DDS::DomainParticipant::_nil();
</pre>
</div>

<p>The <code>DomainParticipantFactory</code> allows creation of 
<code>DomainParticipant</code> objects, while the <code>DomainParticipant</code>
acts as a container of, and a factory for, DDS entities within a specific domain.</p>

<p>When mixing TAO and OpenDDS in the same application, it is necessary to create
a separate <code>argc/argv</code> set for OpenDDS initialization, for two reasons.
The first is that the initialization of OpenDDS (or TAO) will cause command-line
arguments to be consumed, so necessary but already consumed arguments will be unavailable for the initialization
of the other.  The second is that it is important to ensure that
arguments used by TAO and OpenDDS do not conflict.  For instance, 
DataServer would typically be started with an argument such as the following 
on the command line to specify a listening port:</p>

<pre>
-ORBListenEndpoints iiop://:12346
</pre>

<p>Passing this same argument to both TAO and OpenDDS results in an error 
as both would attempt to listen on the same port, so a CORBA
<code>BAD_PARAM</code> exception will be thrown.  As we want that option to be used
only for the initialization of
TAO, and not of OpenDDS, we must create a new <code>argc/argv</code> set 
 to be used for OpenDDS
which does not contain <code>-ORBListenEndpoints</code>.</p>

<div class="code">
<pre>
    try {
        // must duplicate argc/argv as each ORB absorbs parameters
        int argcDDS = 0;
        ACE_TCHAR **argvDDS=new ACE_TCHAR *[argc];
        for (int i=0; i&lt;argc; i++)
            // do not pass -ORBListenEndpoints and its argument
            if (!ACE_OS::strcmp(
                ACE_TEXT("-ORBListenEndpoints"), 
                argv[i]))
                i++;  
            else
                argvDDS[argcDDS++] = ACE_OS::strdup(argv[i]);
</pre>
</div>

<p>We can now initialize the <code>DomainParticipantFactory</code>
with the new <code>argc/argv</code> set.  </p>
<div class="code">
<pre>
        dpf = TheParticipantFactoryWithArgs(argcDDS, argvDDS);
</pre>
</div>

<p><code>TheParticipantFactoryWithArgs()</code> is a macro that expands to:</p>
<pre>
TheServiceParticipant->get_domain_participant_factory(argc, argv)
</pre>
<p>where <code>TheServiceParticipant</code> is a singleton which allows applications to
configure OpenDDS, as well as providing other management features.  For instance, calling 
<code>TheServiceParticipant->shutdown()</code> will terminate OpenDDS processing.</p>

<p>Returning to DataServer, we can create the <code>DomainParticipant</code> for our domain.  DataServer
does not need to participate in more than one domain, so only one <code>DomainParticipant</code>
for the <code>DATABASENOTIFICATION_DOMAIN_ID</code> domain is needed.  
The default quality of service policy is sufficient
for the <code>DomainParticipant</code>, so the <code>PARTICIPANT_QOS_DEFAULT</code>
constant is specified.  For a list of what QoS policies are applied as a default, 
please refer to <a href="#appendixa">Appendix A</a> in this article.</p>

<p>DataServer does not need to monitor any events associated with the <code>DomainParticipant</code>,
so no listener is needed.</p>

<div class="code">
<pre>
        participant = dpf-&gt;create_participant(
            DATABASENOTIFICATION_DOMAIN_ID,
            PARTICIPANT_QOS_DEFAULT,
            DDS::DomainParticipantListener::_nil());
        if (CORBA::is_nil(participant.in())) 
            throw std::exception("create_participant failed");
</pre>
</div>

<p>We must now initialize the transport.  Please refer to <a href="#appendixb">Appendix B</a>
for a discussion on various ways that this can be done.  For flexibility, 
we will choose to have the transport specified via configuration
files, so we add the following to <code>DataServer.cpp</code>:</p>

<div class="code">
<pre>
        const OpenDDS::DCPS::TransportIdType TRANSPORT_IMPL_ID = 1;

        OpenDDS::DCPS::TransportImpl_rch trans_impl =
            TheTransportFactory-&gt;create_transport_impl(
            TRANSPORT_IMPL_ID, 
            OpenDDS::DCPS::AUTO_CONFIG);
</pre>
</div>

<p>We now create a <code>Publisher</code>, using the <code>DomainParticipant</code>
as a factory.  As before, we do not need a listener, 
and the default QoS is sufficient.</p>
<div class="code">
<pre>
        DDS::Publisher_var pub = participant-&gt;create_publisher(
            PUBLISHER_QOS_DEFAULT,
            DDS::PublisherListener::_nil());
        if (CORBA::is_nil(pub.in())) 
            throw std::exception("create_publisher failed");
</pre>
</div>

<p>With the transport defined, we can attach the <code>Publisher</code> to
the transport.</p>

<div class="code">
<pre>
        OpenDDS::DCPS::AttachStatus status = 
            trans_impl-&gt;attach(pub.in());
        if (status != OpenDDS::DCPS::ATTACH_OK) {
            std::string msg("Cannot attach to the transport: ");
            switch (status) {
                case OpenDDS::DCPS::ATTACH_BAD_TRANSPORT:
                    throw std::exception(
                        (msg+"ATTACH_BAD_TRANSPORT").c_str());
                case OpenDDS::DCPS::ATTACH_ERROR:
                    throw std::exception(
                        (msg+"ATTACH_ERROR").c_str());
                case OpenDDS::DCPS::ATTACH_INCOMPATIBLE_QOS:
                    throw std::exception(
                        (msg+"ATTACH_INCOMPATIBLE_QOS").c_str());
                default:
                    throw std::exception(
                        (msg+"unknown status").c_str());
            }
        }
</pre>
</div>

<p>Next, we register the type.  This informs the middleware that the 
database notification type exists, and allows it to manage data of that
type.</p>

<div class="code">
<pre>
        DatabaseNotificationTypeSupport_var 
            databaseNotification_servant 
            = new DatabaseNotificationTypeSupportImpl();
        if (DDS::RETCODE_OK != 
            databaseNotification_servant-&gt;register_type(
                participant.in(), 
                DATABASENOTIFICATION_TYPE))
           throw std::exception("register_type failed");
</pre>
</div>

<p>As the data type itself has been registered, we now inform the middleware
of the topic.  A topic is comprised of a data type, a topic name, QoS, and 
optionally, a listener.  A listener is still not needed, and once again the
default QoS is sufficient.  Although the constant <code>TOPIC_QOS_DEFAULT</code>
could be used, for demonstration purposes we choose to retrieve the default
QoS into a structure via <code>get_default_topic_qos()</code> and apply that
structure as the QoS.</p>

<div class="code">
<pre>
        DDS::TopicQos default_topic_qos;
        participant-&gt;get_default_topic_qos(default_topic_qos);

        DDS::Topic_var databaseNotification_topic =
        participant-&gt;create_topic(
            DATABASENOTIFICATION_TOPIC, 
            DATABASENOTIFICATION_TYPE,
            default_topic_qos, 
            DDS::TopicListener::_nil());
        if (CORBA::is_nil(databaseNotification_topic.in())) 
            throw std::exception("create_topic failed");
</pre>
</div>

<p>Next, we create a data writer for the database notification.  At this
point, we still do not require more than the default QoS, and no listener 
is needed.</p>

<div class="code">
<pre>
        DDS::DataWriterQos dw_default_qos;
        pub->get_default_datawriter_qos(dw_default_qos);

        DDS::DataWriter_var databaseNotification_base_dw =
            pub-&gt;create_datawriter(databaseNotification_topic.in(),
            dw_default_qos,
            DDS::DataWriterListener::_nil());
        if (CORBA::is_nil(databaseNotification_base_dw.in()))
            throw std::exception("create_datawriter failed");

        DatabaseNotificationDataWriter_var databaseNotification_dw
            = DatabaseNotificationDataWriter::_narrow(
                databaseNotification_base_dw.in());
        if (CORBA::is_nil(databaseNotification_dw.in())) 
            throw std::exception(
                "DatabaseNotificationDataWriter could not be narrowed");
</pre>
</div>

<p>To make use of the data writer, we pass it to the servant which implements
the CORBA Database interface that we developed in <a href="MiddlewareNewsBrief-200901.html">part I</a>.</p>

<div class="code">
<pre>
        Database_i servant(%database, databaseNotification_dw.in());
</pre>
</div>

<p>Finally, we must clean up the various DDS components that were allocated.  
<code>delete_contained_entities()</code> is called to free all entities that
are associated with the participant, and the participant itself is freed
with a call to <code>delete_participant()</code>.  If any other <code>DomainParticipants</code>
for other domains were allocated, they must also be freed at this point.  When
no others remain, the <code>TransportFactory</code> is freed and DDS processing 
is terminated by calling <code>shutdown()</code> on <code>TheServiceParticipant</code>.</p>

<div class="code">
<pre>
    try {
        if (!CORBA::is_nil(participant.in()))
            participant->delete_contained_entities();
        if (!CORBA::is_nil(dpf.in()))
            dpf->delete_participant(participant.in());
    } catch (CORBA::Exception&amp; e) {
        std::cerr &lt;&lt; "Exception during cleanup: " &lt;&lt; e &lt;&lt; std::endl;
    }
    TheTransportFactory->release();
    TheServiceParticipant->shutdown();
</pre>
</div>

<p>This completes the changes to <code>DataServer.cpp</code>.  We must now 
update the servant to make use of the data writer.  We first add a member
variable to store a pointer to the data writer, and update the constructor to set the
variable.</p>

<div class="code">
<pre>
// Database_i.h
class Database_i
    : public virtual POA_Database
{
    gcroot&lt;DataLib::Database^&gt; database_;
    DatabaseNotificationDataWriter_ptr dataWriter_;
...
public:
    Database_i(gcroot&lt;DataLib::Database^&gt; database, 
        DatabaseNotificationDataWriter_ptr dataWriter);
</pre>
</div>

<div class="code">
<pre>
// Database_i.cpp
Database_i::Database_i(gcroot&lt;DataLib::Database^&gt; database,
    DatabaseNotificationDataWriter_ptr dataWriter) : 
    database_(database), dataWriter_(dataWriter) 
{
}
</pre>
</div>

<p>Next, we add a helper method, <code>WriteNotification()</code>, which
is called to publish the database notification itself.  The 
<code>DatabaseNotification</code> structure is populated based on
the method parameters, and then passed to <code>write()</code> of the
DataWriter to be published as a DDS sample.  For simplicity, a sample
instance handle is not used, and the constant DDS::HANDLE_NIL is passed instead.</p>

<div class="code">
<pre>
// Database_i.cpp
void Database_i::WriteNotification(::CORBA::LongLong id, 
    ::CORBA::Char *tableName, NotificationType notificationType) {
    DatabaseNotification notification;
    notification.id = id;
    notification.table_name = ::CORBA::string_dup(tableName);
    notification.notification_type = notificationType;

    int ret = dataWriter_-&gt;write(notification, DDS::HANDLE_NIL);
    if (ret != DDS::RETCODE_OK)
        ACE_ERROR ((LM_ERROR, 
        ACE_TEXT("(%P|%t)ERROR: write returned %d.\n"), ret));
}
</pre>
</div>

<p>Each database method is now updated to call <code>WriteNotification()</code>.  
For instance, we modify <code>CreateItem()</code> as follows &mdash; the other
functions are updated in a similar way.</p>

<div class="code">
<pre>
::CORBA::Boolean Database_i::CreateItem (
    const ::CORBA::WChar * description,
    ::CORBA::LongLong_out id)
{
    System::String^ netDescription = 
        gcnew System::String(description);
    ::CORBA::Boolean result = 
        database_->CreateItem(netDescription, id);
    delete netDescription;
    if (result)
        WriteNotification(id, "Items", NOTIFICATION_CREATED);
    return result;
}
</pre>
</div>

<p>To complete the changes to DataServer, we must update <code>DataServer.mpc</code>.
Only two changes are necessary &mdash; the project must inherit from <code>dcpsexe</code>
as this application uses elements of OpenDDS, and a dependency upon <code>DatabaseNotification</code>
is needed, as DataServer must link to the <code>DatabaseNotificationCommon</code> 
library.  The resulting file is as follows:</p>

<div class="code">
<pre>
// DataServer.mpc
project : taoserver, dcpsexe, CPPBase, iortable {
    exename = DataServer
    after += IDL
    after += DataLib
    after += DatabaseNotification
  
    includes += ../IDL
    Source_Files {
        Database_i.cpp
        DataServer.cpp
        ../IDL/DatabaseC.cpp
        ../IDL/DatabaseS.cpp
    }
    IDL_Files {
    }
  
    managed = 1
}
</pre>
</div>

<h2>Subscriber</h2>

<p>With the publisher complete, we can begin the subscriber.  As we mixed 
DDS publisher code with the TAO server in <code>DataServer.cpp</code>, we 
mix DDS subscriber code with the TAO client in <code>DataServerConnectorLib.cpp</code>.
As with the publisher, we again define constants representing the domain, notification
type, and topic, and create variables for the <code>DomainParticipantFactory</code>
and the <code>DomainParticipant</code>.</p>

<div class="code">
<pre>
DDS::DomainId_t DATABASENOTIFICATION_DOMAIN_ID = 1066;
const char* DATABASENOTIFICATION_TYPE = 
    "DatabaseNotification Type";
const char* DATABASENOTIFICATION_TOPIC = 
    "DatabaseNotification Topic";

void DataServerConnector::Run() {
    DDS::DomainParticipantFactory_var dpf = 
        DDS::DomainParticipantFactory::_nil();
    DDS::DomainParticipant_var participant = 
        DDS::DomainParticipant::_nil();
</pre>
</div>

<p>We must create separate <code>argc/argv</code> sets for OpenDDS and TAO
initialization, but as this is the .NET world, it is done slightly differently.
Command-line arguments in .NET are available as an array of .NET strings &mdash; these
must be converted to standard <code>argc/argv</code>.
</p>

<div class="code">
<pre>
    int argc = 0, argc2 = 0;
    wchar_t **argv = NULL, **argv2 = NULL;

    try {
        array&lt;String^&gt;^ arguments = Environment::GetCommandLineArgs();
        argc = arguments->Length;
        argc2 = argc;
        argv = new wchar_t *[argc];
        argv2 = new wchar_t *[argc2];
        for (int i=0; i&lt;argc; i++) {
            pin_ptr&lt;const wchar_t&gt; arg = PtrToStringChars(arguments[i]);
            argv[i] = _wcsdup(arg);
            argv2[i] = _wcsdup(arg);
        }
</pre>
</div>

<p>The initialization of the participant factory, the participant, and the 
transport are identical to that of the publisher.</p>

<div class="code">
<pre>
        dpf = TheParticipantFactoryWithArgs(argc, argv);

        participant = dpf->create_participant(
            DATABASENOTIFICATION_DOMAIN_ID,
            PARTICIPANT_QOS_DEFAULT,
            DDS::DomainParticipantListener::_nil());
        if (CORBA::is_nil(participant.in())) 
            throw std::exception("create_participant failed");

        const OpenDDS::DCPS::TransportIdType TRANSPORT_IMPL_ID = 1;
        OpenDDS::DCPS::TransportImpl_rch trans_impl =
            TheTransportFactory-&gt;create_transport_impl(
                TRANSPORT_IMPL_ID, 
                OpenDDS::DCPS::AUTO_CONFIG);
</pre>
</div>

<p>Next, instead of creating a publisher, we create a subscriber.  No listener
is needed and the default QoS is sufficient.</p>

<div class="code">
<pre>
        DDS::Subscriber_var sub =
            participant-&gt;create_subscriber(SUBSCRIBER_QOS_DEFAULT,
            DDS::SubscriberListener::_nil());
        if (CORBA::is_nil(sub.in())) 
            throw std::exception("create_subscriber failed");
</pre>
</div>

<p>We attach the subscriber to the transport in the same way that the publisher
was attached to the transport.</p>

<div class="code">
<pre>
        OpenDDS::DCPS::AttachStatus status = 
            trans_impl-&gt;attach(sub.in());
        if (status != OpenDDS::DCPS::ATTACH_OK) {
            std::string msg("Cannot attach to the transport: ");
            switch (status) {
                case OpenDDS::DCPS::ATTACH_BAD_TRANSPORT:
                    throw std::exception(
                        (msg+"ATTACH_BAD_TRANSPORT").c_str());
                case OpenDDS::DCPS::ATTACH_ERROR:
                    throw std::exception(
                        (msg+"ATTACH_ERROR").c_str());
                case OpenDDS::DCPS::ATTACH_INCOMPATIBLE_QOS:
                    throw std::exception(
                        (msg+"ATTACH_INCOMPATIBLE_QOS").c_str());
                default:
                    throw std::exception(
                        (msg+"unknown status").c_str());
            }
        }
</pre>
</div>

<p>We also register the type and topic in the same manner as the publisher.</p>

<div class="code">
<pre>
        DatabaseNotificationTypeSupport_var 
            databaseNotification_servant = 
            new DatabaseNotificationTypeSupportImpl();
        if (DDS::RETCODE_OK != 
            databaseNotification_servant-&gt;register_type(
            participant.in(),
            DATABASENOTIFICATION_TYPE)) 
            throw std::exception("register_type failed");

        DDS::TopicQos default_topic_qos;
        participant-&gt;get_default_topic_qos(default_topic_qos);

        DDS::Topic_var databaseNotification_topic =
            participant-&gt;create_topic(
            DATABASENOTIFICATION_TOPIC, 
            DATABASENOTIFICATION_TYPE,
            default_topic_qos, DDS::TopicListener::_nil());
        if (CORBA::is_nil(databaseNotification_topic.in())) 
            throw std::exception("create_topic failed");
</pre>
</div>

<p>We do need a listener for the data reader, so we create an instance of its
implementation, and we pass <code>this</code> as a parameter so the listener
can interact with this class.  The purpose of the listener is to notify 
the application when samples arrive indicating database changes have occurred.
The next section will describe the listener further.</p>

<div class="code">
<pre>
        DDS::DataReaderListener_var 
            databaseNotification_listener(
            new DatabaseNotificationDataReaderListenerImpl(this));
        if (CORBA::is_nil(databaseNotification_listener.in())) 
            throw std::exception("cannot create the listener");
</pre>
</div>

<p>We create a data reader in a manner similar to how we had created the data writer, although
this time we pass a listener reference to <code>create_datareader()</code>.</p>

<div class="code">
<pre>
        DDS::DataReaderQos dr_default_qos;
        sub->get_default_datareader_qos(dr_default_qos);

        DDS::DataReader_var databaseNotification_dr = 
            sub-&gt;create_datareader(databaseNotification_topic.in(),
            dr_default_qos,
            databaseNotification_listener.in());
        if (CORBA::is_nil(databaseNotification_dr.in()))
            throw std::exception("create_datareader failed");
</pre>
</div>

<p>At the end of <code>DataConnector::Run()</code>, we add the same cleanup code
as we did at the end of <code>ACE_TMAIN()</code>, though we format the exception
as a <code>DataConnectorException</code> for processing by the client.</p>

<div class="code">
<pre>
    try {
        if (!CORBA::is_nil(participant.in()))
            participant-&gt;delete_contained_entities();
        if (!CORBA::is_nil(dpf.in()))
            dpf-&gt;delete_participant(participant.in());
    } catch (CORBA::Exception&amp; e) {
        std::stringstream ss;
        ss &lt;&lt; "Exception during cleanup: " &lt;&lt; e;
        throw gcnew 
            DataConnectorException(gcnew String(ss.str().c_str()));
    }
    TheTransportFactory-&gt;release();
    TheServiceParticipant-&gt;shutdown();
</pre>
</div>

<h2>DatabaseNotification Listener</h2>

<p>As samples must be processed when they arrive in order to pass the database
notification to the user of <code>DataServerConnector</code>, a listener for the DataReader is
needed. In the DataServerConnector project, create a file, 
<code>DatabaseNotificationDataReaderListener.h</code>, to implement a subclass
of <code>DDS::DataReaderListener</code>.  We store a reference to the 
<code>DataServerConnector</code>
as a member variable for later use.  As 
<code>DataServerConnector</code> is a .NET type and
<code>DatabaseNotificationDataReaderListenerImpl</code> is not, gcroot&lt;&gt;
is needed. </p>

<div class="code">
<pre>
// DatabaseNotificationDataReaderListener.h
class DatabaseNotificationDataReaderListenerImpl
    : public virtual OpenDDS::DCPS::LocalObject&lt;DDS::DataReaderListener&gt;
{
    gcroot&lt;DataServerConnector^&gt; dataConnector_;
public:
    DatabaseNotificationDataReaderListenerImpl(
        gcroot&lt;DataServerConnector^&gt; dataConnector) : 
        dataConnector_(dataConnector) {}
</pre>
</div>

<p>Only one listener method needs to be implemented, as only the arrival of data
samples is of interest.  We declare <code>on_data_available()</code> to be implemented
in the CPP file, but provide empty bodies for the other methods.</p>

<div class="code">
<pre>
    virtual ~DatabaseNotificationDataReaderListenerImpl() {}

    virtual void on_requested_deadline_missed(
        DDS::DataReader_ptr /*reader*/,
        const DDS::RequestedDeadlineMissedStatus &amp; /*status*/)
        throw (CORBA::SystemException) {}

    virtual void on_requested_incompatible_qos(
        DDS::DataReader_ptr /*reader*/,
        const DDS::RequestedIncompatibleQosStatus &amp; /*status*/)
        throw (CORBA::SystemException) {}

    virtual void on_liveliness_changed(
        DDS::DataReader_ptr /*reader*/,
        const DDS::LivelinessChangedStatus &amp; /*status*/)
        throw (CORBA::SystemException) {}

    virtual void on_subscription_match(
        DDS::DataReader_ptr /*reader*/,
        const DDS::SubscriptionMatchStatus &amp; /*status*/)
        throw (CORBA::SystemException) {}

    virtual void on_sample_rejected(
        DDS::DataReader_ptr /*reader*/,
        const DDS::SampleRejectedStatus &amp; /*status*/)
        throw (CORBA::SystemException) {}

    virtual void on_data_available(
        DDS::DataReader_ptr reader)
        throw (CORBA::SystemException);

    virtual void on_sample_lost(
        DDS::DataReader_ptr /*reader*/,
        const DDS::SampleLostStatus &amp; /*status*/) 
        throw (CORBA::SystemException) {}
};
</pre>
</div>

<p>We next create a CPP file for the implementaton of <code>on_data_available()</code>
named <code>DatabaseNotificationDataReaderListener.cpp</code>.  A DataReader is passed
into the method as a parameter, and must be narrowed to the specific type it represents
&mdash; here, a <code>DatabaseNotificationDataReader</code>.</p>

<div class="code">
<pre>
// DatabaseNotificationDataReaderListener.cpp
void DatabaseNotificationDataReaderListenerImpl::
    on_data_available(DDS::DataReader_ptr reader)
throw (CORBA::SystemException)
{
    try {
        DatabaseNotificationDataReader_var databaseNotification_dr 
            = DatabaseNotificationDataReader::_narrow(reader);
        if (CORBA::is_nil(databaseNotification_dr.in()))
            throw std::exception(
                "DatabaseNotificationDataReaderListenerImpl::"
                "on_data_available: _narrow failed.");
</pre>
</div>

<p>We must now call <code>take_next_sample()</code> until no more data remains.
A <code>DatabaseNotification</code> structure is populated with the data
from the sample, and information
on the sample is returned in the <code>SampleInfo</code> structure.</p>

<div class="code">
<pre>
        while (true) {
            DatabaseNotification notification;
            DDS::SampleInfo si;
            DDS::ReturnCode_t status = 
                databaseNotification_dr-&gt;
                    take_next_sample(notification, si);
</pre>
</div>

<p>If the status returned from <code>take_next_sample()</code> is 
<code>DDS::RETCODE_OK</code>, then further processing is needed, though if the return
is <code>DDS::RETCODE_NO_DATA</code>, then the <code>while</code> loop can be
exited as no more samples are currently available.</p>

<p>If data is available, the <code>instance_state</code> of the 
<code>SampleInfo</code> must be examined.  If the <code>instance_state</code> is either 
ALIVE (there are live DataWriters writing the instance and the samples have 
not been disposed) or NOT_ALIVE_NO_WRITERS (there are no live DataWriters but
the samples have not been disposed), then the sample is valid and should be processed.
The fields of the sample are then converted to .NET types after extracting them
from the <code>DatabaseNotification</code> structure, and the method
<code>ProcessNotification()</code> is called on the <code>DataServerConnector</code>.</p>

<p>If the <code>instance_state</code>
is NOT_ALIVE_DISPOSED, then the samples have been deleted, and should not be
consumed.</p>

<div class="code">
<pre>
        if (status == DDS::RETCODE_OK) {
            if ((si.instance_state == DDS::ALIVE_INSTANCE_STATE) ||
                (si.instance_state == DDS::NOT_ALIVE_NO_WRITERS_INSTANCE_STATE))
                    dataConnector_->ProcessNotification(
                        dataConnector_,
                        gcnew ProcessNotificationEventArgs(
                        notification.id, 
                        gcnew String(notification.table_name.in()), 
                        (Notification)notification.notification_type));
            }
            else if (status == DDS::RETCODE_NO_DATA) 
                break;
        }
</pre>
</div>

<p>We conclude the method by handling exceptions, and re-throwing them as
.NET ones.</p>

<div class="code">
<pre>
    }
    catch (CORBA::Exception&amp; ex) {
        std::stringstream ss;
        ss &lt;&lt; "Exception in read: " &lt;&lt; ex;
        throw gcnew DataConnectorException(
            gcnew String(ss.str().c_str()));
    }
    catch (std::exception&amp; ex) {
        std::stringstream ss;
        ss &lt;&lt; "Exception in read: " &lt;&lt; ex.what();
        throw gcnew DataConnectorException(
            gcnew String(ss.str().c_str()));
    }
}
</pre>
</div>

<p>The listener is now complete, and we can return to <code>DataServerConnector</code>. 
<code>DataServerConnector</code> must provide an interface to allow users of the library
to receive the data received from the DDS sample.  This is accomplished by a .NET 
<em>event</em>.</p>

<p>To create the event, we first construct a <em>delegate</em>.  A delegate is 
essentially a type-safe function pointer, though it may reference more than one
function at a time.  For a discussion of delegates, see 
<a href="#ref1">[1]</a> and
<a href="#ref2">[2]</a>.</p>

<p>We return to <code>DataServerConnectorLib.h</code>, and declare a delegate 
in the <code>DataServerConnector</code> class, and a class member variable
of that type.</p>

<div class="code">
<pre>
// DataServerConnectorLib.h, class DataServerConnector
    delegate void ProcessNotificationEventHandler(Object^ sender, ProcessNotificationEventArgs ^args);
    ProcessNotificationEventHandler^ pProcessNotification_;
</pre>
</div>

<p>The parameters of the delegate match the pattern used by events, as explained in
<a href="#ref3">[3]</a>.  The
first parameter is a reference to a <code>System::Object</code>, a fundamental
.NET type.  The second argument, <code>ProcessNotificationEventArgs</code>, 
is a custom class which is a subclass of the .NET <code>EventArgs</code> class. 
This class is no more than a container for the values from the DDS sample, with
accessor properties to easily retrieve the stored values.  Also in  
<code>DataServerConnectorLib.h</code>, we declare the class as follows:</p>

<div class="code">
<pre>
// DataServerConnectorLib.h
public ref class ProcessNotificationEventArgs : public EventArgs {
    Int64 id_;
    String^ tableName_;
    Notification notificationType_;
public:
    ProcessNotificationEventArgs(Int64 id, String^ tableName, 
        Notification notificationType) : id_(id), 
        tableName_(tableName), notificationType_(notificationType) {}
    property Int64 ID { Int64 get() { return id_; } }
    property String^ TableName { String^ get() { return tableName_; } }
    property Notification NotificationType { 
        Notification get() { return notificationType_; } 
    }
};
</pre>
</div>

<p>We now create the event itself.  In class <code>DataServerConnector</code>,  
declare the event as follows:</p>

<div class="code">
<pre>
// DataServerConnectorLib.h, class DataServerConnector
    event ProcessNotificationEventHandler^ ProcessNotification
    {
        void add(ProcessNotificationEventHandler^ p) 
            { pProcessNotification_ +=p; }
        void remove(ProcessNotificationEventHandler^ p) 
            { pProcessNotification_ -=p; }
        void raise(Object^ obj, ProcessNotificationEventArgs^ args) {
            if (pProcessNotification_!=nullptr)
                pProcessNotification_(obj, args);
        }
    }
</pre>
</div>

<p>The <code>add()</code> method of the event is called whenever an object
wishes to become an observer of the event.  The reference to the object is
added to the delegate variable, and as many observers as desired are
allowed.  Conversely, <code>remove()</code> is called whenever an object
no longer wishes to be an observer of the event.  The <code>raise()</code>
method is called whenever an event is fired, and all observers are notified
of the event.  Note that before invoking the delegate, a test for the
existence of observers must first be performed (a comparison against <code>nullptr</code>) 
&mdash; invoking a null delegate is an error.</p>

<p>Invoking the event as a function, as the listener does in 
<code>on_data_available()</code>:</p>

<div class="code">
<pre>
// DatabaseNotificationDataReaderListener.cpp
dataConnector_->ProcessNotification(dataConnector_,
    gcnew ProcessNotificationEventArgs(
        notification.id, 
        gcnew String(notification.table_name.in()), 
        (Notification)notification.notification_type));
</pre>
</div>

<p>implicitly calls <code>raise()</code>, which then propagates the sample 
data to all observers.</p>

<p>Now that DDS elements have been added to <code>DataServerConnectorLib</code>, we
must update the MPC file to reflect the changes.  The project must now 
inherit from <code>dcps</code>, link with <code>DatabaseNotificationCommon</code>,
reference TAO's <code>orbsvcs</code>, and include <code>DatabaseNotificationDataReaderListenerImpl.cpp</code>
in its compilation.</p>

<div class="code">
<pre>
// DataServerConnectorLib.mpc
project : taoexe, dcps, CPPBase {
    sharedname = DataServerConnectorLib
  
    after += IDL
    includes += ../IDL
    includes += $(TAO_ROOT)/orbsvcs
	
    after += DatabaseNotification
	
    Source_Files {
        DataServerConnectorLib.cpp
        ../IDL/DatabaseC.cpp
        DatabaseNotificationDataReaderListenerImpl.cpp
    }
    IDL_Files {
    }
  
    managed = 1
}
</pre>
</div>

<p>Adding an observer of the event in the Client is simple.  We add a
new method to class <code>Client</code> in <code>Client.cs</code> to 
handle the event &mdash; in this case, log that the event arrived:</p>

<div class="code">
<pre>
// Client.cs
void OnNotification(object obj, ProcessNotificationEventArgs args)
{
    Log("EVENT: Table '" + args.TableName + "', item " + 
        args.ID + " " + args.NotificationType);
}
</pre>
</div>

<p>In the constructor of class <code>Client</code>, we register the 
<code>OnNotification()</code> function with the event, to register the
object as an event observer.</p>

<div class="code">
<pre>
dataConnector_.ProcessNotification += 
    new DataServerConnector.
        ProcessNotificationEventHandler(OnNotification);
</pre>
</div>

<p>In C#, the  <code>+=</code> operation invokes the event's
<code>add()</code> method to perform the observer registration.  
This completes the database notification subscriber.</p>

<h2>Conclusion</h2>

<p>The following screen shots demonstrate the system.  We start two Clients,
as well as the DataServer and the DCPSInfoRepo which are not shown.  For this run, 
the DCPSInfoRepo was run on
the machine <code>oci1373</code> and started with the following command (on a 
single line):</p>
<pre>
DCPSInfoRepo -ORBSvcConf lib_tcp.conf -ORBListenEndpoints iiop://:12345 
    -ORBDottedDecimalAddresses 0
</pre>

<p>The server was started, also on <code>oci1373</code>, with this command
(on a single line):</p>
<pre>
DataServer -ORBSvcConf lib_tcp.conf -ORBListenEndpoints iiop://:12346 
    -DCPSInfoRepo corbaloc::localhost:12345/DCPSInfoRepo 
    -DCPSConfigFile tcp_conf.ini
</pre>    

<p>Each of the Client instances were started with this command (on a single
line):</p>
<pre>
Client -ORBSvcConf lib_tcp.conf -ORBDottedDecimalAddresses 0 
    -ORBInitRef DataServer=corbaloc:iiop:localhost:12346/DataServer 
    -DCPSInfoRepo corbaloc::localhost:12345/DCPSInfoRepo 
    -DCPSConfigFile tcp_conf.ini
</pre>

<p>Note that, when running on multiple hosts, addresses will need to be updated
to use host names or IP addresses as appropriate, instead of <code>localhost</code>.</p>

<p>We enter "My First Item" into the
TextBox associated with the Create button on the first Client.</p>

<div class="center">
<img moz-do-not-send="true"  src="http://www.ociweb.com/mnb/images/200902/s1.png" alt="" width="622" height="331" />
</div>

<p>Pressing the Create button creates the database item, and the generated ID of 
1 is reflected in the ListView.  An event indicating that item 1 in the Items
table was created is also shown in both clients.</p>

<div class="center">
<img moz-do-not-send="true"  src="http://www.ociweb.com/mnb/images/200902/s2.png" alt="" width="620" height="330" />
</div>

<p>On the second Client, we enter the ID of 1 into the TextBox associated with
the Read button.</p>

<div class="center">
<img moz-do-not-send="true"  src="http://www.ociweb.com/mnb/images/200902/s3.png" alt="" width="620" height="330" />
</div>

<p>Pressing the Read button displays "My First Item" as the item description,
demonstrating that the second Client has referenced the same database as the
first Client.  An event indicating that item 1 was read is also shown in
both clients.</p>

<div class="center">
<img moz-do-not-send="true"  src="http://www.ociweb.com/mnb/images/200902/s4.png" alt="" width="620" height="330" />
</div>

<p>This article has described how to mix TAO and OpenDDS in a .NET application to implement
a client-server system.  The next article in this series will illustrate
various refinements to DataServer.</p>

<h2>References</h2>

<p><a name="ref1">[1]</a> An Introduction to Delegates<br/>
<a href="http://msdn.microsoft.com/en-us/magazine/cc301810.aspx">http://msdn.microsoft.com/en-us/magazine/cc301810.aspx</a></p>

<p><a name="ref2">[2]</a> Delegates, Part 2<br/>
<a href="http://msdn.microsoft.com/en-us/magazine/cc301816.aspx">http://msdn.microsoft.com/en-us/magazine/cc301816.aspx</a></p>

<p><a name="ref3">[3]</a> Implementation of Events with Delegates<br/>
<a href="http://msdn.microsoft.com/en-us/magazine/cc301822.aspx">http://msdn.microsoft.com/en-us/magazine/cc301822.aspx</a></p>


<hr/>

<h2><a name="appendixa">Appendix A</a></h2>
<p>As of OpenDDS 1.3, the default quality of service policies correspond to the
following table.</p>


<!-- see Service_Participant::initialize() -->
<table border="1">
<tr>
<th colspan="3">
DomainParticipant
</th>
</tr>


<tr>
<td>USER_DATA</td>
<td>value</td>
<td>(not set)</td>
</tr>

<tr>
<td>ENTITY_FACTORY</td>
<td>autoenable_created_entities</td>
<td>1</td>
</tr>


<tr>
<th colspan="3">
&nbsp;<br/>
Topic
</th>
</tr>

<tr>
<td>TOPIC_DATA</td>
<td>value</td>
<td>(not set)</td>
</tr>

<tr>
<td>DURABILITY</td>
<td>
kind<br/>
service_cleanup_delay.sec<br/>
service_cleanup_delay.nanosec
</td>
<td>
VOLATILE_DURABILITY_QOS<br/>
DURATION_ZERO_SEC<br/>
DURATION_ZERO_NSEC
</td>
</tr>


<tr>
<td>DURABILITY_SERVICE</td>
<td>
service_cleanup_delay.sec<br/>
service_cleanup_delay.nanosec<br/>
history_kind<br/>
history_depth<br/>
max_samples<br/>
max_instances<br/>
max_samples_per_instance
</td>
<td>
DURATION_ZERO_SEC<br/>
DURATION_ZERO_NSEC<br/>
KEEP_LAST_HISTORY_QOS<br/>
1<br/>
LENGTH_UNLIMITED<br/>
LENGTH_UNLIMITED<br/>
LENGTH_UNLIMITED
</td>
</tr>

<tr>
<td>DEADLINE</td>
<td>
period.sec<br/>
period.nanosec
</td>
<td>
DURATION_INFINITY_SEC<br/>
DURATION_INFINITY_NSEC
</td>
</tr>

<tr>
<td>LATENCY_BUDGET</td>
<td>
duration.sec<br/>
duration.nanosec
</td>
<td>
DURATION_ZERO_SEC<br/>
DURATION_ZERO_NSEC
</td>
</tr>

<tr>
<td>LIVELINESS</td>
<td>
kind<br/>
lease_duration.sec<br/>
lease_duration.nanosec<br/>
</td>
<td>
AUTOMATIC_LIVELINESS_QOS<br/>
DURATION_INFINITY_SEC<br/>
DURATION_INFINITY_NSEC
</td>
</tr>

<tr>
<td>RELIABILITY</td>
<td>
kind<br/>
max_blocking_time.sec<br/>
max_blocking_time.nanosec
</td>
<td>
BEST_EFFORT_RELIABILITY_QOS<br/>
DURATION_INFINITY_SEC<br/>
DURATION_INFINITY_NSEC
</td>
</tr>

<tr>
<td>DESTINATION_ORDER</td>
<td>kind</td>
<td>BY_RECEPTION_TIMESTAMP_DESTINATIONORDER_QOS</td>
</tr>

<tr>
<td>HISTORY</td>
<td>
kind<br/>
depth
</td>
<td>
KEEP_LAST_HISTORY_QOS<br/>
1
</td>
</tr>

<tr>
<td>RESOURCE_LIMITS</td>
<td>
max_samples<br/>
max_instances<br/>
max_samples_per_instance
</td>
<td>
LENGTH_UNLIMITED<br/>
LENGTH_UNLIMITED<br/>
LENGTH_UNLIMITED
</td>
</tr>

<tr>
<td>TRANSPORT_PRIORITY</td>
<td>value</td>
<td>0</td>
</tr>

<tr>
<td>LIFESPAN</td>
<td>
duration.sec<br/>
duration.nanosec
</td>
<td>
DURATION_INFINITY_SEC<br/>
DURATION_INFINITY_NSEC
</td>
</tr>

<tr>
<td>OWNERSHIP</td>
<td>
kind<br/>
</td>
<td>
SHARED_OWNERSHIP_QOS<br/>
</td>
</tr>

<tr>
<th colspan="3">
&nbsp;<br/>
Publisher
</th>
</tr>


<tr>
<td>PRESENTATION</td>
<td>
access_scope<br/>
coherent_access<br/>
ordered_access
</td>
<td>
INSTANCE_PRESENTATION_QOS<br/>
0<br/>
0</td>
</tr>

<tr>
<td>PARTITION</td>
<td>name</td>
<td>(empty sequence)</td>
</tr>

<tr>
<td>GROUP_DATA</td>
<td>value</td>
<td>(not set)</td>
</tr>

<tr>
<td>ENTITY_FACTORY</td>
<td>autoenable_created_entities</td>
<td>1</td>
</tr>


<tr>
<th colspan="3">
&nbsp;<br/>
Subscriber
</th>
</tr>


<tr>
<td>PRESENTATION</td>
<td>
access_scope<br/>
coherent_access<br/>
ordered_access
</td>
<td>
INSTANCE_PRESENTATION_QOS<br/>
0<br/>
0</td>
</tr>

<tr>
<td>PARTITION</td>
<td>name</td>
<td>(empty sequence)</td>
</tr>

<tr>
<td>GROUP_DATA</td>
<td>value</td>
<td>(not set)</td>
</tr>

<tr>
<td>ENTITY_FACTORY</td>
<td>autoenable_created_entities</td>
<td>1</td>
</tr>


<tr>
<th colspan="3">
&nbsp;<br/>
DataWriter
</th>
</tr>

<tr>
<td>DURABILITY</td>
<td>
kind<br/>
service_cleanup_delay.sec<br/>
service_cleanup_delay.nanosec
</td>
<td>
VOLATILE_DURABILITY_QOS<br/>
DURATION_ZERO_SEC<br/>
DURATION_ZERO_NSEC
</td>
</tr>


<tr>
<td>DURABILITY_SERVICE</td>
<td>
service_cleanup_delay.sec<br/>
service_cleanup_delay.nanosec<br/>
history_kind<br/>
history_depth<br/>
max_samples<br/>
max_instances<br/>
max_samples_per_instance
</td>
<td>
DURATION_ZERO_SEC<br/>
DURATION_ZERO_NSEC<br/>
KEEP_LAST_HISTORY_QOS<br/>
1<br/>
LENGTH_UNLIMITED<br/>
LENGTH_UNLIMITED<br/>
LENGTH_UNLIMITED
</td>
</tr>

<tr>
<td>DEADLINE</td>
<td>
period.sec<br/>
period.nanosec
</td>
<td>
DURATION_INFINITY_SEC<br/>
DURATION_INFINITY_NSEC
</td>
</tr>

<tr>
<td>LATENCY_BUDGET</td>
<td>
duration.sec<br/>
duration.nanosec
</td>
<td>
DURATION_ZERO_SEC<br/>
DURATION_ZERO_NSEC
</td>
</tr>


<tr>
<td>LIVELINESS</td>
<td>
kind<br/>
lease_duration.sec<br/>
lease_duration.nanosec<br/>
</td>
<td>
AUTOMATIC_LIVELINESS_QOS<br/>
DURATION_INFINITY_SEC<br/>
DURATION_INFINITY_NSEC
</td>
</tr>

<tr>
<td>RELIABILITY</td>
<td>
kind<br/>
max_blocking_time.sec<br/>
max_blocking_time.nanosec
</td>
<td>
BEST_EFFORT_RELIABILITY_QOS<br/>
DURATION_INFINITY_SEC<br/>
DURATION_INFINITY_NSEC
</td>
</tr>

<tr>
<td>DESTINATION_ORDER</td>
<td>kind</td>
<td>BY_RECEPTION_TIMESTAMP_DESTINATIONORDER_QOS</td>
</tr>

<tr>
<td>HISTORY</td>
<td>
kind<br/>
depth
</td>
<td>
KEEP_LAST_HISTORY_QOS<br/>
1
</td>
</tr>

<tr>
<td>RESOURCE_LIMITS</td>
<td>
max_samples<br/>
max_instances<br/>
max_samples_per_instance
</td>
<td>
LENGTH_UNLIMITED<br/>
LENGTH_UNLIMITED<br/>
LENGTH_UNLIMITED
</td>
</tr>

<tr>
<td>TRANSPORT_PRIORITY</td>
<td>value</td>
<td>0</td>
</tr>

<tr>
<td>LIFESPAN</td>
<td>
duration.sec<br/>
duration.nanosec
</td>
<td>
DURATION_INFINITY_SEC<br/>
DURATION_INFINITY_NSEC
</td>
</tr>

<tr>
<td>USER_DATA</td>
<td>value</td>
<td>(not set)</td>
</tr>

<tr>
<td>OWNERSHIP</td>
<td>
kind<br/>
</td>
<td>
SHARED_OWNERSHIP_QOS<br/>
</td>
</tr>

<tr>
<td>OWNERSHIP_STRENGTH</td>
<td>value</td>
<td>0</td>
</tr>

<tr>
<td>WRITER_DATA_LIFECYCLE</td>
<td>autodispose_unregistered_instances</td>
<td>1</td>
</tr>

     

<tr>
<th colspan="3">
&nbsp;<br/>
DataReader
</th>
</tr>


<tr>
<td>DURABILITY</td>
<td>
kind<br/>
service_cleanup_delay.sec<br/>
service_cleanup_delay.nanosec
</td>
<td>
VOLATILE_DURABILITY_QOS<br/>
DURATION_ZERO_SEC<br/>
DURATION_ZERO_NSEC
</td>
</tr>


<tr>
<td>DEADLINE</td>
<td>
period.sec<br/>
period.nanosec
</td>
<td>
DURATION_INFINITY_SEC<br/>
DURATION_INFINITY_NSEC
</td>
</tr>

<tr>
<td>LATENCY_BUDGET</td>
<td>
duration.sec<br/>
duration.nanosec
</td>
<td>
DURATION_ZERO_SEC<br/>
DURATION_ZERO_NSEC
</td>
</tr>


<tr>
<td>LIVELINESS</td>
<td>
kind<br/>
lease_duration.sec<br/>
lease_duration.nanosec<br/>
</td>
<td>
AUTOMATIC_LIVELINESS_QOS<br/>
DURATION_INFINITY_SEC<br/>
DURATION_INFINITY_NSEC
</td>
</tr>

<tr>
<td>RELIABILITY</td>
<td>
kind<br/>
max_blocking_time.sec<br/>
max_blocking_time.nanosec
</td>
<td>
BEST_EFFORT_RELIABILITY_QOS<br/>
DURATION_INFINITY_SEC<br/>
DURATION_INFINITY_NSEC
</td>
</tr>

<tr>
<td>DESTINATION_ORDER</td>
<td>kind</td>
<td>BY_RECEPTION_TIMESTAMP_DESTINATIONORDER_QOS</td>
</tr>


<tr>
<td>HISTORY</td>
<td>
kind<br/>
depth
</td>
<td>
KEEP_LAST_HISTORY_QOS<br/>
1
</td>
</tr>

<tr>
<td>RESOURCE_LIMITS</td>
<td>
max_samples<br/>
max_instances<br/>
max_samples_per_instance
</td>
<td>
LENGTH_UNLIMITED<br/>
LENGTH_UNLIMITED<br/>
LENGTH_UNLIMITED
</td>
</tr>


<tr>
<td>USER_DATA</td>
<td>value</td>
<td>(not set)</td>
</tr>

<tr>
<td>TIME_BASED_FILTER</td>
<td>
minimum_separation.sec<br/>
minimum_separation.nanosec
</td>
<td>
DURATION_ZERO_SEC<br/>
DURATION_ZERO_NSEC
</td>
</tr>


<tr>
<td>READER_DATA_LIFECYCLE</td>
<td>
autopurge_nowriter_samples_delay.sec<br/>
autopurge_nowriter_samples_delay.nanosec
</td>
<td>
DURATION_ZERO_SEC<br/>
DURATION_ZERO_NSEC
</td>
</tr>

<tr>
<td>OWNERSHIP</td>
<td>
kind<br/>
</td>
<td>
SHARED_OWNERSHIP_QOS<br/>
</td>
</tr>

</table>


<hr/>

<h2><a name="appendixb">Appendix B</a></h2>

<p>A transport can be selected in several different ways.  One way is to defer the 
selection of the transport to the user at runtime.  For example, the following 
process allows the <code>SimpleTcp</code> transport to be used.</p>

<h4>Method 1</h4>
<p>For this method, create two files in the filesystem.  Name the first file
<code>lib_tcp.conf</code>, and add the following to it (as one line):</p>

<div class="code">
<pre>
// lib_tcp.conf
dynamic DCPS_SimpleTcpLoader Service_Object * 
    SimpleTcp:_make_DCPS_SimpleTcpLoader() "-type SimpleTcp"
</pre>
</div>

<p>Name the second file <code>tcp_conf.ini</code>, and include a section to
configure SimpleTcp transport parameters, as follows</p>

<div class="code">
<pre>
// tcp_conf.ini
[transport_impl_1]
transport_type=SimpleTcp
</pre>
</div>

<p>In <code>DataServer.cpp</code>, define a constant equal to the same value as
the number of the section in <code>tcp_conf.ini</code> &mdash; here, the value 1,
to match <code>transport_impl_1</code> &mdash; and then use 
<code>create_transport_impl()</code> to create the transport:</p>

<div class="code">
<pre>
// DataServer.cpp (method 1)
const OpenDDS::DCPS::TransportIdType TRANSPORT_IMPL_ID = 1;

OpenDDS::DCPS::TransportImpl_rch trans_impl =
    TheTransportFactory-&gt;create_transport_impl(
        TRANSPORT_IMPL_ID, 
        OpenDDS::DCPS::AUTO_CONFIG);
</pre>
</div>

<p>When DataServer is run with these command-line arguments:</p>

<pre>
-ORBSvcConf lib_tcp.conf -DCPSConfigFile tcp_conf.ini
</pre>

<p>the <code>SimpleTcp</code> transport will be loaded by <code>lib_tcp.conf</code>, referenced
as the transport to use in <code>tcp_conf.ini</code>, and instantiated by
<code>create_transport_impl()</code>.</p>

<h4>Method 2</h4>

<p>A second way to load a transport is entirely within code, by name, so external
configuration files are not required.  A call to <code>get_or_create_configuration()</code>
will load a specific transport at the specified ID for use by <code>create_transport_impl()</code>:</p>

<div class="code">
<pre>
// DataServer.cpp (method 2)
const OpenDDS::DCPS::TransportIdType TRANSPORT_IMPL_ID = 1;

TheTransportFactory-&gt;get_or_create_configuration(
    TRANSPORT_IMPL_ID, ACE_TEXT("SimpleTcp"));
    
OpenDDS::DCPS::TransportImpl_rch trans_impl =
    TheTransportFactory-&gt;create_transport_impl(
        TRANSPORT_IMPL_ID, 
        OpenDDS::DCPS::AUTO_CONFIG);
</pre>
</div>

<h4>Method 3</h4>
<p>A third way is to use constants for transport IDs that have been predefined
for the standard transports, rather than defining an ID of our own:</p>

<div class="code">
<pre>
// DataServer.cpp (method 3)
OpenDDS::DCPS::TransportImpl_rch trans_impl =
    TheTransportFactory-&gt;create_transport_impl(
        ::OpenDDS::DCPS::DEFAULT_SIMPLE_TCP_ID, 
        OpenDDS::DCPS::AUTO_CONFIG);
</pre>
</div>

<!-- tbd: Stop the Middleware News Brief here -->

<hr class="Color" />
<!--#include virtual="./includes/services.html"-->
<hr class="Color" />
<!--#include virtual="./includes/footer.html"-->
<hr class="Color" />
<!--#include virtual="./includes/copyright2009.html"-->
<div class="quicklinks">
<a href="#top">Top</a>
</div>
</body>
</html>
